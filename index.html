<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Conquest</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bungee+Shade&family=Creepster&family=Permanent+Marker&family=Fredoka:wght@600&family=Playfair+Display:wght@700&family=Mystery+Quest&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #0f172a;
            color: #e2e8f0;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        /* ===== Menu Screen ===== */
        #menu-screen {
            position: fixed; inset: 0; z-index: 200;
            background: linear-gradient(180deg, #0a1628 0%, #0f2940 30%, #134b5f 60%, #1a5c3a 85%, #0f3d1f 100%);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            transition: opacity 0.6s ease, transform 0.6s ease;
            overflow: hidden;
        }
        .menu-decorations {
            position: absolute; inset: 0;
            pointer-events: none;
            z-index: 0;
        }
        .menu-ground {
            position: absolute; bottom: 0; left: 0; right: 0;
            height: 60px;
            background: linear-gradient(180deg, #2d5a1e 0%, #1a3d12 100%);
            pointer-events: none;
            z-index: 0;
        }
        .menu-title, .menu-subtitle, .menu-cards, .menu-options-btn {
            position: relative; z-index: 1;
        }
        .deco {
            position: absolute;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .deco-palm-left { left: 2%; bottom: 20px; width: 140px; opacity: 0.95; }
        .deco-palm-right { right: 3%; bottom: 30px; width: 120px; opacity: 0.95; transform: scaleX(-1); }
        .deco-palm-bg { left: 15%; bottom: 40px; width: 100px; opacity: 0.3; }
        .deco-bush-left { left: 8%; bottom: 15px; width: 80px; }
        .deco-bush-right { right: 10%; bottom: 15px; width: 55px; }
        .deco-grass-1 { left: 20%; bottom: 10px; width: 60px; opacity: 0.8; }
        .deco-grass-2 { right: 22%; bottom: 8px; width: 40px; opacity: 0.7; }
        .deco-grass-3 { left: 45%; bottom: 12px; width: 50px; opacity: 0.6; }
        .deco-flower-red { left: 12%; bottom: 35px; width: 20px; }
        .deco-flower-purple { right: 15%; bottom: 40px; width: 18px; }
        .deco-flower-yellow { left: 30%; bottom: 28px; width: 16px; }
        #menu-screen.hidden {
            opacity: 0; transform: scale(1.05);
            pointer-events: none;
        }

        .menu-title {
            font-size: 52px; font-weight: 900;
            background: linear-gradient(135deg, #60a5fa, #a78bfa, #f87171);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
            text-align: center;
        }
        .menu-subtitle {
            font-size: 16px; color: #64748b;
            margin-bottom: 48px; text-align: center;
        }

        .menu-cards {
            display: flex; gap: 20px;
            flex-wrap: wrap; justify-content: center;
            max-width: 740px;
        }

        .menu-card {
            width: 210px; padding: 28px 20px;
            background: #1e293b; border-radius: 16px;
            text-align: center; cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.25s, border-color 0.25s, box-shadow 0.25s;
        }
        .menu-card:hover {
            transform: translateY(-6px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.4);
        }
        .menu-card.pvp:hover { border-color: #a78bfa; }
        .menu-card.pvc:hover { border-color: #60a5fa; }
        .menu-card.tutorial:hover { border-color: #34d399; }

        .menu-card-icon { font-size: 40px; margin-bottom: 12px; }
        .menu-card-title { font-size: 20px; font-weight: 700; margin-bottom: 6px; }
        .menu-card-desc { font-size: 13px; color: #94a3b8; line-height: 1.4; }

        .menu-card.pvp .menu-card-title { color: #a78bfa; }
        .menu-card.pvc .menu-card-title { color: #60a5fa; }
        .menu-card.tutorial .menu-card-title { color: #34d399; }

        /* ===== Options Screen ===== */
        #options-screen {
            position: fixed; inset: 0; z-index: 210;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            transition: opacity 0.4s ease, transform 0.4s ease;
            overflow-y: auto;
            padding: 24px 0;
        }
        #options-screen.hidden {
            opacity: 0; transform: scale(1.05);
            pointer-events: none;
        }
        .options-title {
            font-size: 36px; font-weight: 900; color: #e2e8f0;
            margin-bottom: 20px;
        }
        .options-section {
            background: #1e293b; border-radius: 12px;
            padding: 16px 28px; margin-bottom: 8px;
            min-width: 340px; max-width: 420px;
        }
        .options-section-title { font-size: 16px; font-weight: 700; color: #e2e8f0; margin-bottom: 4px; }
        .options-section-desc { font-size: 12px; color: #64748b; margin-bottom: 12px; line-height: 1.4; }
        .options-hint { font-size: 12px; color: #94a3b8; margin-top: 8px; font-style: italic; }
        .options-buttons { display: flex; gap: 8px; }
        .options-buttons-5 .opt-btn { padding: 10px 8px; font-size: 13px; }
        .opt-btn {
            flex: 1; padding: 10px 16px; border-radius: 8px;
            border: 2px solid #334155; background: #0f172a; color: #94a3b8;
            font-size: 14px; font-weight: 600; cursor: pointer;
            transition: all 0.2s;
        }
        .opt-btn:hover { border-color: #60a5fa; color: #e2e8f0; }
        .opt-btn.opt-active { border-color: #60a5fa; background: #1e3a5f; color: #60a5fa; }
        .options-turns-row { display: flex; align-items: center; }
        .opt-turns-input {
            width: 64px; padding: 10px 12px; border-radius: 8px;
            border: 2px solid #334155; background: #0f172a; color: #e2e8f0;
            font-size: 16px; font-weight: 600; text-align: center;
            outline: none; transition: border-color 0.2s;
            -moz-appearance: textfield;
        }
        .opt-turns-input::-webkit-outer-spin-button,
        .opt-turns-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .opt-turns-input:focus { border-color: #60a5fa; }
        .opt-turns-input.input-error { border-color: #ef4444; }
        .turns-error { color: #ef4444; font-weight: 600; }
        .menu-options-btn {
            margin-top: 20px; padding: 12px 32px;
            border-radius: 10px; border: 2px solid #334155;
            background: #1e293b; color: #94a3b8;
            font-size: 15px; font-weight: 600; cursor: pointer;
            transition: all 0.25s;
        }
        .menu-options-btn:hover { border-color: #a78bfa; color: #e2e8f0; transform: translateY(-2px); }

        /* ===== Turn Timer ===== */
        #turn-timer {
            font-size: 18px; font-weight: 700; color: #fbbf24;
            margin-top: 2px; transition: color 0.3s;
        }
        #turn-timer.timer-urgent {
            color: #ef4444;
            animation: timer-pulse 0.5s ease-in-out infinite alternate;
        }
        @keyframes timer-pulse {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0.7; transform: scale(1.15); }
        }

        /* ===== Header ===== */
        #header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 24px;
            background: #1e293b;
            border-radius: 12px;
            margin-bottom: 12px;
            width: 100%;
            max-width: 900px;
        }

        .score-box { font-size: 19px; font-weight: 700; min-width: 130px; transition: transform 0.3s ease, font-weight 0.3s ease; }
        .score-box.score-animating { transform: scale(1.3); font-weight: 900; }
        .score-label { font-size: 10px; font-weight: 400; text-transform: uppercase; letter-spacing: 1px; opacity: 0.7; margin-bottom: 1px; }
        .score-value { font-size: 19px; }
        #blue-score { color: #60a5fa; text-align: left; }
        #red-score  { color: #f87171; text-align: right; }
        #turn-info { text-align: center; flex: 1; }

        #turn-indicator {
            font-size: 19px; font-weight: 700;
            transition: color 0.3s, transform 0.2s;
            display: inline-block;
        }
        #turn-indicator.pulse {
            animation: turnPulse 0.35s ease-out;
        }
        @keyframes turnPulse {
            0% { transform: scale(1); }
            40% { transform: scale(1.25); }
            100% { transform: scale(1); }
        }

        #turns-left { font-size: 12px; color: #94a3b8; margin-top: 2px; }
        .turns-blue { color: #60a5fa; }
        .turns-red { color: #f87171; }

        #sound-toggle {
            padding: 6px 12px; font-size: 12px; font-weight: 600;
            background: #334155; color: #94a3b8; border: none; border-radius: 6px;
            cursor: pointer; margin-left: 12px; white-space: nowrap;
        }
        #sound-toggle:hover { background: #475569; }

        #game-area {
            display: flex;
            gap: 16px;
            align-items: flex-start;
            max-width: 900px;
            width: 100%;
            justify-content: center;
        }

        #main-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #word-display {
            text-align: center;
            font-size: 27px;
            font-family: 'Courier New', monospace;
            font-weight: 700;
            padding: 8px;
            min-height: 42px;
            margin-bottom: 6px;
            color: #94a3b8;
            transition: transform 0.15s ease;
        }
        #word-display.word-pop {
            animation: wordPop 0.3s ease-out;
        }
        @keyframes wordPop {
            0% { transform: scale(1); }
            40% { transform: scale(1.15); }
            100% { transform: scale(1); }
        }

        #gameCanvas {
            border-radius: 8px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            height: auto;
            transition: box-shadow 0.5s ease;
        }

        #controls {
            display: flex;
            gap: 10px;
            margin-top: 12px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 8px 20px; font-size: 14px; font-weight: 600;
            border: none; border-radius: 8px; cursor: pointer;
            background: #334155; color: #e2e8f0;
            transition: background 0.2s, transform 0.15s, box-shadow 0.2s;
        }
        button:hover { background: #475569; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        button:active { transform: translateY(0); box-shadow: none; }
        button:disabled { opacity: 0.4; cursor: default; transform: none; box-shadow: none; }

        #btn-submit { background: #059669; color: #fff; }
        #btn-submit:hover:not(:disabled) { background: #047857; box-shadow: 0 4px 16px rgba(5,150,105,0.3); }

        #btn-pass { background: #92400e; color: #fff; }
        #btn-pass:hover:not(:disabled) { background: #78350f; }

        #btn-accept { background: #b45309; color: #fff; display: none; }
        #btn-accept:hover { background: #a16207; }

        #message {
            text-align: center; font-size: 14px; padding: 8px;
            min-height: 34px; color: #fbbf24;
            transition: opacity 0.5s; opacity: 0;
        }

        /* ===== History sidebar ===== */
        #history-panel {
            width: 220px;
            min-width: 220px;
            background: #1e293b;
            border-radius: 12px;
            padding: 14px;
            max-height: 680px;
            display: flex;
            flex-direction: column;
        }

        #history-panel h3 {
            font-size: 14px;
            color: #94a3b8;
            margin-bottom: 10px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #history-list {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        #history-list::-webkit-scrollbar { width: 4px; }
        #history-list::-webkit-scrollbar-track { background: transparent; }
        #history-list::-webkit-scrollbar-thumb { background: #475569; border-radius: 2px; }

        .history-entry {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            background: #0f172a;
            border-radius: 6px;
            font-size: 13px;
        }

        .history-dot {
            width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0;
        }
        .history-dot.blue { background: #3b82f6; }
        .history-dot.red { background: #ef4444; }

        .history-word {
            font-family: 'Courier New', monospace;
            font-weight: 700;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .history-info {
            font-size: 11px;
            color: #94a3b8;
            text-align: right;
            white-space: nowrap;
        }

        .history-pass {
            color: #64748b;
            font-style: italic;
        }

        .history-collinear {
            color: #94a3b8;
        }

        .history-empty {
            color: #475569;
            font-style: italic;
            text-align: center;
            padding: 20px 0;
            font-size: 13px;
        }

        /* ===== Pass confirm ===== */
        #pass-confirm {
            display: none; position: fixed; inset: 0;
            background: rgba(0,0,0,0.4); z-index: 100;
            justify-content: center; align-items: center;
        }
        #pass-confirm.visible { display: flex; }
        #duck-taunt, #goat-taunt, #hippo-taunt, #flamingo-taunt, #turtle-taunt, #raccoon-taunt, #squirrel-taunt, #panda-taunt, #penguin-taunt, #walrus-taunt, #snake-taunt {
            display: none; position: fixed; inset: 0;
            background: rgba(0,0,0,0.5); z-index: 100;
            justify-content: center; align-items: center;
        }
        #duck-taunt.visible, #goat-taunt.visible, #hippo-taunt.visible, #flamingo-taunt.visible, #turtle-taunt.visible, #raccoon-taunt.visible, #squirrel-taunt.visible, #panda-taunt.visible, #penguin-taunt.visible, #walrus-taunt.visible, #snake-taunt.visible { display: flex; }
        .pass-confirm-content {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 10px;
            padding: 18px 28px;
            text-align: center;
        }
        .pass-confirm-content p {
            font-size: 15px; color: #e2e8f0; margin-bottom: 14px;
        }
        .pass-confirm-buttons { display: flex; gap: 10px; justify-content: center; }
        .pass-confirm-buttons button { padding: 7px 24px; font-size: 13px; border-radius: 7px; }
        .pass-yes { background: #92400e; color: #fff; }
        .pass-yes:hover { background: #78350f; }
        .pass-no { background: #334155; color: #e2e8f0; }
        .pass-no:hover { background: #475569; }

        /* ===== Game over overlay ===== */
        #game-over {
            display: none; position: fixed; inset: 0;
            background: rgba(0,0,0,0.75); z-index: 100;
            justify-content: center; align-items: center;
        }
        #game-over.visible { display: flex; }

        .game-over-content {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-radius: 16px;
            padding: 40px 56px; text-align: center;
            box-shadow: 0 8px 40px rgba(0,0,0,0.6);
            animation: popIn 0.3s ease-out;
        }
        .game-over-content h1 {
            font-size: 34px; margin-bottom: 10px;
            text-shadow: 0 0 30px currentColor;
        }
        #final-scores { font-size: 20px; margin-bottom: 6px; color: #cbd5e1; }
        #winner-subtitle { font-size: 15px; color: #94a3b8; margin-bottom: 22px; }
        .game-over-content button {
            padding: 12px 36px; font-size: 17px;
            background: #059669; color: #fff; border-radius: 10px;
        }
        .game-over-content button:hover { background: #047857; }

        @keyframes popIn {
            from { transform: scale(0.85); opacity: 0; }
            to   { transform: scale(1);    opacity: 1; }
        }

        /* ===== Tutorial overlay ===== */
        #tutorial-overlay {
            display: none; position: fixed;
            bottom: 12px; right: 12px;
            z-index: 150;
            background: linear-gradient(135deg, #1e293b, #0f172a);
            border: 2px solid #34d399;
            border-radius: 12px;
            padding: 12px 16px;
            max-width: 280px; width: auto;
            text-align: center;
            box-shadow: 0 6px 24px rgba(52,211,153,0.15);
            animation: slideIn 0.3s ease-out;
        }
        #tutorial-overlay.visible { display: block; }
        @keyframes slideIn {
            from { transform: translateX(20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        #tutorial-step-title {
            font-size: 13px; font-weight: 700; color: #34d399;
            margin-bottom: 4px;
        }
        #tutorial-step-desc {
            font-size: 11px; color: #cbd5e1; line-height: 1.4;
            margin-bottom: 10px;
        }
        .tutorial-buttons { display: flex; gap: 8px; justify-content: center; }
        .tutorial-buttons button {
            padding: 6px 16px; font-size: 12px; border-radius: 6px;
        }
        @media (min-width: 921px) {
            #tutorial-overlay {
                max-width: 340px;
                padding: 16px 22px;
            }
            #tutorial-step-title { font-size: 16px; margin-bottom: 6px; }
            #tutorial-step-desc { font-size: 14px; line-height: 1.5; margin-bottom: 14px; }
            .tutorial-buttons button { padding: 8px 22px; font-size: 14px; }
            .score-label { font-size: 14px; }
            .score-value { font-size: 27px; }
            .score-box { font-size: 27px; min-width: 170px; }
            #turn-indicator { font-size: 27px; }
            #turns-left { font-size: 17px; }
        }
        #btn-tutorial-next { background: #34d399; color: #0f172a; font-weight: 700; }
        #btn-tutorial-next:hover { background: #6ee7b7; }
        #btn-tutorial-skip { background: #475569; color: #e2e8f0; }
        #btn-tutorial-skip:hover { background: #64748b; }

        /* ===== Online / Lobby Screens ===== */
        #online-screen {
            position: fixed; inset: 0; z-index: 210;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            transition: opacity 0.4s ease, transform 0.4s ease;
        }
        #online-screen.hidden {
            opacity: 0; transform: scale(1.05);
            pointer-events: none;
        }
        .online-title {
            font-size: 36px; font-weight: 900; color: #e2e8f0;
            margin-bottom: 32px;
        }
        .online-sections {
            display: flex; gap: 24px; flex-wrap: wrap; justify-content: center;
        }
        .online-section {
            background: #1e293b; border-radius: 12px;
            padding: 28px 32px; min-width: 260px; text-align: center;
            border: 2px solid #334155;
        }
        .online-section h3 {
            font-size: 18px; font-weight: 700; color: #f59e0b;
            margin-bottom: 16px;
        }
        .online-section p {
            font-size: 13px; color: #94a3b8; margin-bottom: 16px; line-height: 1.5;
        }
        .online-section button {
            padding: 10px 28px; font-size: 15px; font-weight: 600;
            background: #f59e0b; color: #0f172a; border-radius: 8px;
            border: none; cursor: pointer; transition: background 0.2s, transform 0.15s;
        }
        .online-section button:hover {
            background: #fbbf24; transform: translateY(-2px);
        }
        .online-code-input {
            width: 160px; padding: 10px 14px; border-radius: 8px;
            border: 2px solid #334155; background: #0f172a; color: #e2e8f0;
            font-size: 20px; font-weight: 700; text-align: center;
            letter-spacing: 4px; text-transform: uppercase;
            outline: none; transition: border-color 0.2s;
            font-family: 'Courier New', monospace;
            margin-bottom: 12px; display: block; margin-left: auto; margin-right: auto;
        }
        .online-code-input:focus { border-color: #f59e0b; }
        .online-back-btn {
            margin-top: 28px; padding: 10px 28px; border-radius: 8px;
            border: 2px solid #334155; background: #1e293b; color: #94a3b8;
            font-size: 14px; font-weight: 600; cursor: pointer;
            transition: all 0.2s;
        }
        .online-back-btn:hover {
            border-color: #f59e0b; color: #e2e8f0; transform: translateY(-2px);
        }

        #lobby-screen {
            position: fixed; inset: 0; z-index: 210;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            transition: opacity 0.4s ease, transform 0.4s ease;
        }
        #lobby-screen.hidden {
            opacity: 0; transform: scale(1.05);
            pointer-events: none;
        }
        .lobby-label {
            font-size: 16px; color: #94a3b8; margin-bottom: 12px;
        }
        .lobby-code {
            font-size: 56px; font-weight: 900; letter-spacing: 12px;
            color: #f59e0b; font-family: 'Courier New', monospace;
            margin-bottom: 8px;
        }
        .lobby-status {
            font-size: 16px; color: #64748b; margin-bottom: 24px;
        }
        .lobby-status .dot {
            display: inline-block; width: 8px; height: 8px; border-radius: 50%;
            background: #f59e0b; margin-right: 6px;
            animation: lobby-pulse 1.2s ease-in-out infinite alternate;
        }
        @keyframes lobby-pulse {
            from { opacity: 0.4; } to { opacity: 1; }
        }
        .lobby-buttons { display: flex; gap: 12px; }
        .lobby-buttons button {
            padding: 10px 24px; font-size: 14px; border-radius: 8px;
        }
        .lobby-copy-btn {
            background: #334155; color: #e2e8f0;
        }
        .lobby-copy-btn:hover { background: #475569; }
        .lobby-cancel-btn {
            background: #92400e; color: #fff;
        }
        .lobby-cancel-btn:hover { background: #78350f; }

        /* Online menu card */
        .menu-card.online:hover { border-color: #f59e0b; }
        .menu-card.online .menu-card-title { color: #f59e0b; }

        /* Online indicator */
        #online-indicator {
            position: fixed; top: 12px; right: 12px; z-index: 90;
            background: #1e293b; border-radius: 8px;
            padding: 8px 14px; font-size: 12px;
            border: 1px solid #334155;
            display: none;
        }
        #online-indicator .online-role {
            font-weight: 700; margin-bottom: 2px;
        }
        #online-indicator .online-conn {
            display: flex; align-items: center; gap: 5px; color: #64748b; font-size: 11px;
        }
        #online-indicator .conn-dot {
            width: 6px; height: 6px; border-radius: 50%;
        }
        #online-indicator .conn-dot.connected { background: #34d399; }
        #online-indicator .conn-dot.disconnected { background: #ef4444; }

        /* ===== Quest Mode ===== */
        .menu-card.quest:hover { border-color: #f97316; }
        .menu-card.quest .menu-card-title { color: #f97316; }

        #quest-screen {
            position: fixed; inset: 0; z-index: 210;
            background: linear-gradient(180deg, #06050f 0%, #0d0b1a 30%, #0f172a 70%, #0a1020 100%);
            display: flex; flex-direction: column;
            align-items: center; justify-content: flex-end;
            transition: opacity 0.4s ease;
            overflow: hidden;
        }
        #quest-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* The vertical chain container — positioned so current is centered */
        #quest-chain {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: bottom 1.2s cubic-bezier(0.22, 1, 0.36, 1);
        }

        /* Single node: connector line + card */
        .quest-node {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Vertical connector line between nodes */
        .quest-connector {
            width: 4px;
            height: 80px;
            background: linear-gradient(180deg, #334155 0%, #475569 50%, #334155 100%);
            position: relative;
        }
        .quest-connector.defeated-line {
            background: linear-gradient(180deg, #166534 0%, #22c55e 50%, #166534 100%);
            box-shadow: 0 0 8px rgba(34,197,94,0.3);
        }
        /* Glowing dot at connector midpoint */
        .quest-connector::after {
            content: '';
            position: absolute; left: 50%; top: 50%;
            transform: translate(-50%, -50%);
            width: 10px; height: 10px; border-radius: 50%;
            background: #475569;
        }
        .quest-connector.defeated-line::after {
            background: #22c55e;
            box-shadow: 0 0 10px rgba(34,197,94,0.5);
        }

        /* Enemy card — landscape rectangle, width = 2x height */
        .quest-enemy-card {
            width: min(50vw, 480px);
            aspect-ratio: 2 / 1;
            background: #111827;
            border-radius: 14px;
            border: 3px solid #1e293b;
            display: flex;
            align-items: stretch;
            overflow: hidden;
            position: relative;
            transition: border-color 0.4s, box-shadow 0.4s, opacity 0.4s, filter 0.4s;
        }

        /* Current enemy — bold glowing border */
        .quest-enemy-card.available {
            border-color: #f97316;
            box-shadow:
                0 0 20px rgba(249,115,22,0.4),
                0 0 50px rgba(249,115,22,0.15),
                inset 0 0 30px rgba(249,115,22,0.05);
            animation: quest-current-pulse 2s ease-in-out infinite alternate;
        }
        @keyframes quest-current-pulse {
            from {
                box-shadow:
                    0 0 15px rgba(249,115,22,0.3),
                    0 0 40px rgba(249,115,22,0.1),
                    inset 0 0 20px rgba(249,115,22,0.03);
            }
            to {
                box-shadow:
                    0 0 30px rgba(249,115,22,0.55),
                    0 0 70px rgba(249,115,22,0.2),
                    inset 0 0 40px rgba(249,115,22,0.08);
                border-color: #fb923c;
            }
        }

        .quest-enemy-card.defeated {
            border-color: #166534;
            box-shadow: 0 0 12px rgba(34,197,94,0.15);
        }
        .quest-enemy-card.locked {
            border-color: #1e293b;
            opacity: 0.35;
            filter: grayscale(0.8) brightness(0.6);
        }

        /* Image takes left ~45% */
        .quest-enemy-card .qec-img-wrap {
            width: 45%;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }
        .quest-enemy-card .qec-img-wrap img {
            width: 100%; height: 100%;
            object-fit: cover;
            display: block;
        }
        /* Gradient fade from image to info */
        .quest-enemy-card .qec-img-wrap::after {
            content: '';
            position: absolute; top: 0; right: 0;
            width: 40%; height: 100%;
            background: linear-gradient(90deg, transparent, #111827);
        }
        /* Defeated checkmark overlay */
        .quest-enemy-card.defeated .qec-img-wrap::before {
            content: '\2714';
            position: absolute; top: 8px; left: 8px; z-index: 2;
            width: 28px; height: 28px; border-radius: 50%;
            background: #16a34a;
            color: #fff; font-size: 15px; font-weight: 900;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        /* Info panel on the right */
        .quest-enemy-card .qec-info {
            flex: 1; display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 12px 16px 12px 4px;
            position: relative; z-index: 1;
        }

        .quest-enemy-card .qec-name {
            font-size: clamp(16px, 2.5vw, 22px);
            color: #e2e8f0;
            margin-bottom: 4px;
            line-height: 1.2;
        }
        /* Per-enemy fonts */
        .quest-enemy-card[data-enemy="goat"] .qec-name {
            font-family: 'Fredoka', sans-serif;
            color: #f9a8d4;
        }
        .quest-enemy-card[data-enemy="hippo"] .qec-name {
            font-family: 'Bungee Shade', cursive;
            color: #facc15;
        }
        .quest-enemy-card[data-enemy="flamingo"] .qec-name {
            font-family: 'Fredoka', sans-serif;
            color: #f472b6;
        }
        .quest-enemy-card[data-enemy="duck"] .qec-name {
            font-family: 'Creepster', cursive;
            color: #a78bfa;
            letter-spacing: 1px;
        }
        .quest-enemy-card[data-enemy="turtle"] .qec-name {
            font-family: 'Fredoka', sans-serif;
            color: #2dd4bf;
            letter-spacing: 1px;
        }
        .quest-enemy-card[data-enemy="raccoon"] .qec-name {
            font-family: 'Permanent Marker', cursive;
            color: #fb923c;
        }
        .quest-enemy-card[data-enemy="squirrel"] .qec-name {
            font-family: 'Fredoka', sans-serif;
            color: #4ade80;
        }
        .quest-enemy-card[data-enemy="panda"] .qec-name {
            font-family: 'Creepster', cursive;
            color: #a3e635;
        }
        .quest-enemy-card[data-enemy="penguin"] .qec-name {
            font-family: 'Playfair Display', serif;
            color: #93c5fd;
            font-style: italic;
        }
        .quest-enemy-card[data-enemy="walrus"] .qec-name {
            font-family: 'Mystery Quest', cursive;
            color: #c084fc;
            font-size: clamp(18px, 2.8vw, 26px);
        }

        .quest-enemy-card .qec-diff {
            font-size: 10px; font-weight: 700; text-transform: uppercase;
            letter-spacing: 2px; margin-bottom: 6px;
        }
        .qec-diff.easy { color: #34d399; }
        .qec-diff.medium { color: #fbbf24; }
        .qec-diff.expert { color: #f87171; }

        .quest-enemy-card .qec-power {
            font-size: 11px; color: #94a3b8; line-height: 1.35;
            margin-bottom: 10px;
        }

        .quest-battle-btn {
            align-self: flex-start;
            padding: 7px 22px; border-radius: 8px;
            background: linear-gradient(135deg, #f97316, #ea580c);
            color: #fff; border: none;
            font-size: 13px; font-weight: 700; cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .quest-battle-btn:hover {
            transform: scale(1.06);
            box-shadow: 0 4px 20px rgba(249,115,22,0.4);
        }

        .quest-status-badge {
            align-self: flex-start;
            display: inline-block; padding: 4px 12px;
            border-radius: 6px; font-size: 11px; font-weight: 700;
        }
        .quest-status-badge.defeated-badge {
            background: rgba(22,101,52,0.3); color: #4ade80;
        }
        .quest-status-badge.locked-badge {
            background: rgba(100,116,139,0.15); color: #64748b;
        }

        /* Bottom controls bar */
        .quest-bottom-bar {
            position: relative; z-index: 5;
            display: flex; gap: 12px;
            padding: 16px 20px 24px;
            align-items: center;
        }
        .quest-back-btn {
            padding: 10px 28px; border-radius: 8px;
            border: 2px solid #334155; background: #1e293b; color: #94a3b8;
            font-size: 14px; font-weight: 600; cursor: pointer;
            transition: all 0.2s;
        }
        .quest-back-btn:hover { border-color: #f97316; color: #e2e8f0; transform: translateY(-2px); }
        .quest-reset-btn {
            padding: 8px 16px; border-radius: 6px;
            border: 1px solid #475569; background: transparent; color: #64748b;
            font-size: 12px; cursor: pointer; transition: all 0.2s;
        }
        .quest-reset-btn:hover { border-color: #ef4444; color: #ef4444; }

        /* Transition flash overlay for scrolling */
        #quest-flash {
            position: absolute; inset: 0; z-index: 4;
            pointer-events: none; opacity: 0;
            background: radial-gradient(ellipse at center, rgba(249,115,22,0.3) 0%, transparent 70%);
            transition: opacity 0.3s;
        }
        #quest-flash.flash-active {
            animation: quest-flash-burst 1.2s ease-out forwards;
        }
        @keyframes quest-flash-burst {
            0% { opacity: 0; }
            15% { opacity: 1; }
            40% { opacity: 0.6; }
            100% { opacity: 0; }
        }

        /* Sparkle particles during scroll */
        .quest-sparkle {
            position: absolute; border-radius: 50%;
            pointer-events: none; z-index: 3;
            background: #f97316;
            animation: quest-sparkle-fly 1s ease-out forwards;
        }
        @keyframes quest-sparkle-fly {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0) translateY(-60px); }
        }

        /* Quest Indicator (during gameplay) */
        #quest-indicator {
            position: fixed; top: 12px; right: 12px; z-index: 90;
            background: #1e293b; border-radius: 10px;
            padding: 10px 14px; font-size: 12px;
            border: 1px solid #f97316;
            display: none; max-width: 200px;
        }
        #quest-indicator .qi-header {
            display: flex; align-items: center; gap: 8px; margin-bottom: 4px;
        }
        #quest-indicator .qi-img {
            width: 36px; height: 36px; border-radius: 50%; object-fit: cover;
        }
        #quest-indicator .qi-name {
            font-weight: 700; color: #f97316; font-size: 13px;
        }
        #quest-indicator .qi-power {
            color: #94a3b8; font-size: 11px; line-height: 1.3;
        }

        /* Shakeup overlay */
        #shakeup-overlay {
            display: none; position: fixed; inset: 0;
            background: rgba(0,0,0,0.7); z-index: 300;
            justify-content: center; align-items: center;
        }
        #shakeup-overlay.visible { display: flex; }
        .shakeup-content {
            text-align: center; animation: popIn 0.3s ease-out;
        }
        .shakeup-content img {
            width: 100px; height: 100px; border-radius: 50%;
            object-fit: cover; border: 3px solid #fbbf24;
            margin-bottom: 12px;
            animation: shakeup-shake 0.4s ease-in-out infinite alternate;
        }
        @keyframes shakeup-shake {
            from { transform: rotate(-5deg) scale(1); }
            to { transform: rotate(5deg) scale(1.05); }
        }
        .shakeup-content h2 {
            font-size: 28px; color: #fbbf24; margin-bottom: 6px;
        }
        .shakeup-content p { font-size: 14px; color: #94a3b8; }

        /* Spell overlay */
        #spell-overlay {
            display: none; position: fixed; inset: 0;
            background: rgba(0,0,0,0.75); z-index: 300;
            justify-content: center; align-items: center;
        }
        #spell-overlay.visible { display: flex; }
        .spell-content {
            text-align: center; animation: popIn 0.3s ease-out;
        }
        .spell-content img {
            width: 90px; height: 90px; border-radius: 50%;
            object-fit: cover; border: 3px solid #a78bfa;
            margin-bottom: 12px;
            animation: spell-pulse 0.6s ease-in-out infinite alternate;
        }
        @keyframes spell-pulse {
            from { box-shadow: 0 0 10px rgba(167,139,250,0.3); }
            to { box-shadow: 0 0 30px rgba(167,139,250,0.7); }
        }
        .spell-content h2 {
            font-size: 24px; color: #a78bfa; margin-bottom: 4px;
        }
        .spell-content p { font-size: 14px; color: #cbd5e1; margin-bottom: 4px; }
        .spell-content .spell-effect { font-size: 12px; color: #94a3b8; }

        /* Victory screen */
        #victory-screen {
            display: none; position: fixed; inset: 0;
            background: rgba(0,0,0,0.85); z-index: 310;
            justify-content: center; align-items: center;
            flex-direction: column;
        }
        #victory-screen.visible { display: flex; }
        .victory-content {
            text-align: center; animation: popIn 0.5s ease-out;
            position: relative; z-index: 1;
        }
        .victory-content h1 {
            font-size: 48px; font-weight: 900;
            background: linear-gradient(135deg, #fbbf24, #f97316, #ef4444);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 16px;
        }
        .victory-content .victory-subtitle {
            font-size: 18px; color: #94a3b8; margin-bottom: 24px;
        }
        .victory-portraits {
            display: flex; gap: 12px; justify-content: center;
            flex-wrap: wrap; margin-bottom: 28px;
        }
        .victory-portrait {
            width: 70px; height: 70px; border-radius: 50%;
            object-fit: cover; border: 3px solid #34d399;
            box-shadow: 0 0 12px rgba(52,211,153,0.3);
        }
        .victory-content button {
            padding: 14px 40px; font-size: 17px;
            background: #f97316; color: #fff; border-radius: 10px;
            font-weight: 700;
        }
        .victory-content button:hover { background: #ea580c; }

        /* Confetti canvas */
        #confetti-canvas {
            position: fixed; inset: 0; z-index: 305;
            pointer-events: none;
        }

        /* Frozen cell shimmer */
        @keyframes frozen-shimmer {
            0% { opacity: 0.4; }
            50% { opacity: 0.7; }
            100% { opacity: 0.4; }
        }

        /* Letter bounce animation for hippo swap */
        @keyframes letter-bounce {
            0% { transform: scale(1); }
            30% { transform: scale(1.4); }
            60% { transform: scale(0.9); }
            100% { transform: scale(1); }
        }

        /* ===== Responsive ===== */
        @media (max-width: 920px) {
            #game-area { flex-direction: column; align-items: center; }
            #history-panel {
                width: 100%; max-width: 600px;
                max-height: 180px; min-width: auto;
            }
        }

        @media (max-width: 700px) {
            body { padding: 10px; }
            #header { padding: 10px 14px; min-width: auto; }
            .score-box { font-size: 15px; min-width: 90px; }
            .score-label { font-size: 8px; }
            .score-value { font-size: 14px; }
            #turns-left { font-size: 10px; }
            #turn-indicator { font-size: 15px; }
            #word-display { font-size: 22px; }
            #controls { gap: 6px; }
            button { padding: 7px 14px; font-size: 13px; }
            .menu-title { font-size: 36px; }
            .menu-card { width: 180px; padding: 20px 16px; }
            .deco-palm-left { width: 90px; }
            .deco-palm-right { width: 80px; }
            .deco-palm-bg { width: 70px; }
            .deco-bush-left { width: 55px; }
            .deco-bush-right { width: 40px; }
            .options-section { min-width: 280px; padding: 16px 20px; }
            #online-screen {
                justify-content: flex-start;
                padding-top: 24px;
                overflow-y: auto;
            }
            .online-title { font-size: 28px; }
            .online-section { min-width: 220px; padding: 20px 18px; }
            .lobby-code { font-size: 40px; letter-spacing: 8px; }
            #online-indicator { font-size: 11px; padding: 6px 10px; }
            .quest-enemy-card { width: min(80vw, 360px); }
            .quest-connector { height: 50px; }
            .quest-enemy-card .qec-name { font-size: clamp(13px, 3.5vw, 18px); }
            .quest-enemy-card .qec-power { font-size: 10px; }
            #quest-indicator { max-width: 160px; font-size: 11px; }
            #quest-indicator .qi-img { width: 30px; height: 30px; }
            .victory-portrait { width: 55px; height: 55px; }
            .victory-content h1 { font-size: 36px; }
        }
    </style>
    <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-database-compat.js"></script>
</head>
<body>
    <!-- Menu Screen -->
    <div id="menu-screen">
        <div class="menu-title">Word Conquest</div>
        <div class="menu-subtitle">Capture territory by spelling words on the grid</div>
        <div class="menu-cards">
            <div class="menu-card pvp" onclick="startGame('pvp')">
                <div class="menu-card-icon">&#9876;&#65039;</div>
                <div class="menu-card-title">Player vs Player</div>
                <div class="menu-card-desc">Two players take turns on the same device</div>
            </div>
            <div class="menu-card pvc" onclick="startGame('pvc')">
                <div class="menu-card-icon">&#129302;</div>
                <div class="menu-card-title">Player vs Computer</div>
                <div class="menu-card-desc">Challenge the AI opponent</div>
            </div>
            <div class="menu-card tutorial" onclick="startGame('tutorial')">
                <div class="menu-card-icon">&#128218;</div>
                <div class="menu-card-title">Tutorial</div>
                <div class="menu-card-desc">Learn how to play step by step</div>
            </div>
            <div class="menu-card online" onclick="showOnlineScreen()">
                <div class="menu-card-icon">&#127760;</div>
                <div class="menu-card-title">Online</div>
                <div class="menu-card-desc">Play against a friend over the internet</div>
            </div>
            <div class="menu-card quest" onclick="showQuestScreen()">
                <div class="menu-card-icon">&#127965;</div>
                <div class="menu-card-title">Campaign</div>
                <div class="menu-card-desc" id="quest-card-desc"></div>
            </div>
        </div>
        <!-- Temporary test dropdown -->
        <div style="text-align:center; margin-top:18px;">
            <select id="quest-test-select" style="padding:8px 16px; font-size:16px; border-radius:8px; border:2px solid #f97316; background:#1a1a2e; color:#fff; cursor:pointer;">
                <option value="" disabled selected>-- Test Campaign Battle --</option>
            </select>
        </div>
        <button class="menu-options-btn" onclick="openOptions()">Options</button>
        <div class="menu-decorations">
            <img class="deco deco-palm-left" alt="">
            <img class="deco deco-palm-right" alt="">
            <img class="deco deco-palm-bg" alt="">
            <img class="deco deco-bush-left" alt="">
            <img class="deco deco-bush-right" alt="">
            <img class="deco deco-grass-1" alt="">
            <img class="deco deco-grass-2" alt="">
            <img class="deco deco-grass-3" alt="">
            <img class="deco deco-flower-red" alt="">
            <img class="deco deco-flower-purple" alt="">
            <img class="deco deco-flower-yellow" alt="">
        </div>
        <div class="menu-ground"></div>
    </div>

    <!-- Options Screen -->
    <div id="options-screen" class="hidden">
        <div class="options-title">Options</div>

        <div class="options-section">
            <div class="options-section-title">Computer Difficulty</div>
            <div class="options-buttons">
                <button class="opt-btn" onclick="setDifficulty('easy')" id="opt-easy">Easy</button>
                <button class="opt-btn opt-active" onclick="setDifficulty('medium')" id="opt-medium">Medium</button>
                <button class="opt-btn" onclick="setDifficulty('expert')" id="opt-expert">Expert</button>
            </div>
            <div class="options-hint" id="difficulty-hint">Default balanced AI.</div>
        </div>

        <div class="options-section">
            <div class="options-section-title">Turn Timer</div>
            <div class="options-buttons">
                <button class="opt-btn opt-active" onclick="setTimerOption(0)" id="opt-timer-off">Off</button>
                <button class="opt-btn" onclick="setTimerOption(30)" id="opt-timer-30">30s</button>
                <button class="opt-btn" onclick="setTimerOption(60)" id="opt-timer-60">1 min</button>
            </div>
        </div>

        <div class="options-section">
            <div class="options-section-title">Board Size</div>
            <div class="options-buttons options-buttons-5">
                <button class="opt-btn" onclick="setBoardSize(9)" id="opt-size-9">9&times;9</button>
                <button class="opt-btn" onclick="setBoardSize(10)" id="opt-size-10">10&times;10</button>
                <button class="opt-btn opt-active" onclick="setBoardSize(11)" id="opt-size-11">11&times;11</button>
                <button class="opt-btn" onclick="setBoardSize(12)" id="opt-size-12">12&times;12</button>
                <button class="opt-btn" onclick="setBoardSize(13)" id="opt-size-13">13&times;13</button>
            </div>
            <div class="options-hint" id="size-hint">Default board size.</div>
        </div>

        <div class="options-section">
            <div class="options-section-title">Turns Per Player</div>
            <div class="options-section-desc">Number of turns each player takes before the game ends.</div>
            <div class="options-turns-row">
                <input type="number" id="opt-turns" class="opt-turns-input" value="8" min="1" max="20" oninput="setTurnsOption()">
                <span class="options-hint" id="turns-hint" style="margin-top:0; margin-left:12px;"></span>
            </div>
        </div>

        <button class="menu-options-btn" onclick="closeOptions()" style="margin-top:32px;">Back to Menu</button>
    </div>

    <!-- Online Screen -->
    <div id="online-screen" class="hidden">
        <div class="online-title">Online Multiplayer</div>
        <div class="online-sections">
            <div class="online-section">
                <h3>Create Game</h3>
                <p>Start a new game and share the code with a friend.</p>
                <button onclick="createOnlineGame()">Create Game</button>
            </div>
            <div class="online-section">
                <h3>Join Game</h3>
                <p>Enter the 6-character code to join an existing game.</p>
                <input type="text" id="join-code-input" class="online-code-input" maxlength="6" placeholder="ABC123" autocomplete="off" onfocus="setTimeout(()=>this.scrollIntoView({block:'center',behavior:'smooth'}),300)">
                <button onclick="joinOnlineGame()">Join Game</button>
            </div>
        </div>
        <button class="online-back-btn" onclick="hideOnlineScreen()">Back to Menu</button>
    </div>

    <!-- Lobby Screen -->
    <div id="lobby-screen" class="hidden">
        <div class="lobby-label">Share this code with your opponent:</div>
        <div class="lobby-code" id="lobby-code-display">------</div>
        <div class="lobby-status" id="lobby-status"><span class="dot"></span> Waiting for opponent...</div>
        <div class="lobby-buttons">
            <button class="lobby-copy-btn" onclick="copyGameCode()">Copy Code</button>
            <button class="lobby-cancel-btn" onclick="cancelLobby()">Cancel</button>
        </div>
    </div>

    <!-- Quest Screen -->
    <div id="quest-screen" class="hidden">
        <div id="quest-flash"></div>
        <div id="quest-chain"></div>
        <div class="quest-bottom-bar">
            <button class="quest-back-btn" onclick="hideQuestScreen()">Back to Menu</button>
            <button class="quest-reset-btn" onclick="resetQuestProgress()">Reset Progress</button>
        </div>
    </div>

    <!-- Shakeup Overlay -->
    <div id="shakeup-overlay">
        <div class="shakeup-content">
            <img id="shakeup-img" src="" alt="">
            <h2>Board Shakeup!</h2>
            <p>Letters scrambled!</p>
        </div>
    </div>

    <!-- Spell Overlay -->
    <div id="spell-overlay">
        <div class="spell-content">
            <img id="spell-img" src="" alt="">
            <h2 id="spell-name"></h2>
            <p id="spell-desc"></p>
            <div class="spell-effect" id="spell-effect"></div>
        </div>
    </div>

    <!-- Victory Screen -->
    <div id="victory-screen">
        <canvas id="confetti-canvas"></canvas>
        <div class="victory-content">
            <h1>Campaign Complete!</h1>
            <div class="victory-subtitle" id="victory-subtitle"></div>
            <div class="victory-portraits" id="victory-portraits"></div>
            <button onclick="hideVictoryScreen()">Return to Menu</button>
        </div>
    </div>

    <!-- Quest Indicator (during gameplay) -->
    <div id="quest-indicator">
        <div class="qi-header">
            <img class="qi-img" id="qi-img" src="" alt="">
            <span class="qi-name" id="qi-name"></span>
        </div>
        <div class="qi-power" id="qi-power"></div>
    </div>

    <!-- Online Indicator -->
    <div id="online-indicator">
        <div class="online-role" id="online-role-text"></div>
        <div class="online-conn">
            <span class="conn-dot connected" id="online-conn-dot"></span>
            <span id="online-conn-text">Connected</span>
        </div>
    </div>

    <div id="header">
        <div id="blue-score" class="score-box">
            <div class="score-label">Territory</div>
            <div class="score-value" id="blue-score-value">Blue: 0.0%</div>
        </div>
        <div id="turn-info">
            <div id="turn-indicator">Blue's Turn</div>
            <div id="turns-left"><span class="turns-blue">Blue: 8</span> | <span class="turns-red">Red: 8</span></div>
            <div id="turn-timer" style="display:none;"></div>
        </div>
        <div style="display:flex;align-items:center">
            <div id="red-score" class="score-box">
                <div class="score-label">Territory</div>
                <div class="score-value" id="red-score-value">Red: 0.0%</div>
            </div>
            <button id="sound-toggle" onclick="toggleSound()">Sound: OFF</button>
        </div>
    </div>

    <div id="game-area">
        <div id="main-panel">
            <div id="word-display">Select letters to form a word...</div>
            <canvas id="gameCanvas" width="600" height="600"></canvas>
            <div id="controls">
                <button id="btn-submit" onclick="submitWord()">Submit Word</button>
                <button id="btn-undo" onclick="undoSelection()">Undo</button>
                <button id="btn-clear" onclick="clearSelections()">Clear</button>
                <button id="btn-pass" onclick="passTurn()">Pass</button>
                <button id="btn-accept" onclick="acceptAnyway()">Accept Anyway</button>
            </div>
            <div id="message"></div>
        </div>

        <div id="history-panel">
            <h3>Turn History</h3>
            <div id="history-list">
                <div class="history-empty">No turns yet</div>
            </div>
        </div>
    </div>

    <div id="game-over">
        <div class="game-over-content">
            <h1 id="winner-title">Game Over!</h1>
            <p id="final-scores"></p>
            <p id="winner-subtitle"></p>
            <button id="btn-game-over" onclick="newGame()">New Game</button>
        </div>
    </div>

    <div id="pass-confirm">
        <div class="pass-confirm-content">
            <p>Pass your turn?</p>
            <div class="pass-confirm-buttons">
                <button class="pass-yes" onclick="confirmPass()">Yes</button>
                <button class="pass-no" onclick="cancelPass()">No</button>
            </div>
        </div>
    </div>

    <!-- Duck taunt dialog -->
    <div id="duck-taunt">
        <div class="pass-confirm-content" style="max-width:320px;">
            <img id="duck-taunt-img" src="Images for Quest Mode/Dastardly Duck.jpg" alt="Dastardly Duck" style="width:80px;height:80px;border-radius:50%;object-fit:cover;border:3px solid #a78bfa;margin-bottom:10px;">
            <p style="font-size:14px;line-height:1.5;color:#e2e8f0;">I'm Dastardly Duck! I'm so dastardly, I took some of the territory already. hahaha! <em>*Quack*</em></p>
            <div class="pass-confirm-buttons" style="margin-top:14px;">
                <button class="pass-yes" onclick="dismissDuckTaunt()" style="background:#a78bfa;">Bring it on!</button>
            </div>
        </div>
    </div>

    <div id="hippo-taunt">
        <div class="pass-confirm-content" style="max-width:340px;">
            <img src="Images for Quest Mode/Hip Hop Hippo.jpg" alt="Hip Hop Hippo" style="width:100px;height:100px;border-radius:50%;object-fit:cover;border:3px solid #facc15;margin-bottom:10px;">
            <p style="font-size:14px;line-height:1.5;color:#e2e8f0;">I'm Hip Hop Hippo! I'm so fast with words, I play twice before each of your turns. Can you keep up with my flow?</p>
            <div class="pass-confirm-buttons" style="margin-top:14px;">
                <button class="pass-yes" onclick="dismissHippoTaunt()" style="background:#facc15;color:#1e293b;">Let's go!</button>
            </div>
        </div>
    </div>

    <div id="walrus-taunt">
        <div class="pass-confirm-content" style="max-width:340px;">
            <img src="Images for Quest Mode/Wizardly Walrus.jpg" alt="Wizardly Walrus" style="width:100px;height:100px;border-radius:50%;object-fit:cover;border:3px solid #c084fc;margin-bottom:10px;">
            <p style="font-size:14px;line-height:1.5;color:#e2e8f0;">I'm Wizardly Walrus! I have spells powerful enough to make any opponent TREMBLE UNDER MY MIGHY TUSKS!!!</p>
            <div class="pass-confirm-buttons" style="margin-top:14px;">
                <button class="pass-yes" onclick="dismissWalrusTaunt()" style="background:#c084fc;color:#1e293b;">Let's go!</button>
            </div>
        </div>
    </div>

    <div id="panda-taunt">
        <div class="pass-confirm-content" style="max-width:340px;">
            <img src="Images for Quest Mode/Petty Panda.jpg" alt="Petty Panda" style="width:100px;height:100px;border-radius:50%;object-fit:cover;border:3px solid #a3e635;margin-bottom:10px;">
            <p style="font-size:14px;line-height:1.5;color:#e2e8f0;">I'm Petty Panda! I don't like sharing, so you stick to your half of the board and I'll stick to mine.</p>
            <div class="pass-confirm-buttons" style="margin-top:14px;">
                <button class="pass-yes" onclick="dismissPandaTaunt()" style="background:#a3e635;color:#1e293b;">Let's go!</button>
            </div>
        </div>
    </div>

    <div id="snake-taunt">
        <div class="pass-confirm-content" style="max-width:340px;">
            <img src="Images for Quest Mode/Sneaky Snake.jpg" alt="Sneaky Snake" style="width:100px;height:100px;border-radius:50%;object-fit:cover;border:3px solid #10b981;margin-bottom:10px;">
            <p style="font-size:14px;line-height:1.5;color:#e2e8f0;">I'm Sneaky Snake! I keep our territories hidden until the game is over.</p>
            <div class="pass-confirm-buttons" style="margin-top:14px;">
                <button class="pass-yes" onclick="dismissSnakeTaunt()" style="background:#10b981;color:#1e293b;">Let's go!</button>
            </div>
        </div>
    </div>

    <div id="penguin-taunt">
        <div class="pass-confirm-content" style="max-width:340px;">
            <img src="Images for Quest Mode/Professor Penguin.jpg" alt="Professor Penguin" style="width:100px;height:100px;border-radius:50%;object-fit:cover;border:3px solid #93c5fd;margin-bottom:10px;">
            <p style="font-size:14px;line-height:1.5;color:#e2e8f0;">I'm Professor Penguin! I play long science words because I'm smarter than you.</p>
            <div class="pass-confirm-buttons" style="margin-top:14px;">
                <button class="pass-yes" onclick="dismissPenguinTaunt()" style="background:#93c5fd;color:#1e293b;">Let's go!</button>
            </div>
        </div>
    </div>

    <div id="squirrel-taunt">
        <div class="pass-confirm-content" style="max-width:340px;">
            <img src="Images for Quest Mode/Stretchy Squirrel.jpg" alt="Stretchy Squirrel" style="width:100px;height:100px;border-radius:50%;object-fit:cover;border:3px solid #4ade80;margin-bottom:10px;">
            <p style="font-size:14px;line-height:1.5;color:#e2e8f0;">I'm streeeeeeeeetchy Squirrel! I can reach extra far for my next letter.</p>
            <div class="pass-confirm-buttons" style="margin-top:14px;">
                <button class="pass-yes" onclick="dismissSquirrelTaunt()" style="background:#4ade80;color:#1e293b;">Let's go!</button>
            </div>
        </div>
    </div>

    <div id="flamingo-taunt">
        <div class="pass-confirm-content" style="max-width:340px;">
            <img src="Images for Quest Mode/Foolish Flamingo.jpg" alt="Foolish Flamingo" style="width:100px;height:100px;border-radius:50%;object-fit:cover;border:3px solid #f472b6;margin-bottom:10px;">
            <p style="font-size:14px;line-height:1.5;color:#e2e8f0;">I'm Foolish Flamingo! I don't know any words longer than 3 letters, so you aren't allowed to play any either!</p>
            <div class="pass-confirm-buttons" style="margin-top:14px;">
                <button class="pass-yes" onclick="dismissFlamingoTaunt()" style="background:#f472b6;color:#1e293b;">Let's go!</button>
            </div>
        </div>
    </div>

    <div id="turtle-taunt">
        <div class="pass-confirm-content" style="max-width:340px;">
            <img src="Images for Quest Mode/Tenacious Turtle.jpg" alt="Tenacious Turtle" style="width:100px;height:100px;border-radius:50%;object-fit:cover;border:3px solid #2dd4bf;margin-bottom:10px;">
            <p style="font-size:14px;line-height:1.5;color:#e2e8f0;">I'm Tenacious Turtle! I capture all my territories at maximum strength</p>
            <div class="pass-confirm-buttons" style="margin-top:14px;">
                <button class="pass-yes" onclick="dismissTurtleTaunt()" style="background:#2dd4bf;color:#1e293b;">Let's go!</button>
            </div>
        </div>
    </div>

    <div id="raccoon-taunt">
        <div class="pass-confirm-content" style="max-width:340px;">
            <img src="Images for Quest Mode/Rowdy Raccoon.jpg" alt="Rowdy Raccoon" style="width:100px;height:100px;border-radius:50%;object-fit:cover;border:3px solid #fb923c;margin-bottom:10px;">
            <p style="font-size:14px;line-height:1.5;color:#e2e8f0;">I'm Rowdy Raccoon! Every once and a while I like to go crazy and throw letters around. I can't help it!</p>
            <div class="pass-confirm-buttons" style="margin-top:14px;">
                <button class="pass-yes" onclick="dismissRaccoonTaunt()" style="background:#fb923c;color:#1e293b;">Let's go!</button>
            </div>
        </div>
    </div>

    <div id="goat-taunt">
        <div class="pass-confirm-content" style="max-width:340px;">
            <img src="Images for Quest Mode/Goofy Goat.jpg" alt="Goofy Goat" style="width:100px;height:100px;border-radius:50%;object-fit:cover;border:3px solid #f9a8d4;margin-bottom:10px;">
            <p style="font-size:14px;line-height:1.5;color:#e2e8f0;">I'm Goofy Goat! I don't have any special powers, and I'm not very good. I just like to be goofy!</p>
            <div class="pass-confirm-buttons" style="margin-top:14px;">
                <button class="pass-yes" onclick="dismissGoatTaunt()" style="background:#f9a8d4;color:#1e293b;">Let's go!</button>
            </div>
        </div>
    </div>

    <!-- Tutorial overlay -->
    <div id="tutorial-overlay">
        <div id="tutorial-step-title"></div>
        <div id="tutorial-step-desc"></div>
        <div class="tutorial-buttons">
            <button id="btn-tutorial-next" onclick="tutorialNext()">Next</button>
            <button id="btn-tutorial-skip" onclick="tutorialSkip()">Skip Tutorial</button>
        </div>
    </div>

    <script>
        /* ===== Constants ===== */
        let GRID = 11;
        const CELL = 50;
        let GRID_PX = GRID * CELL;
        const PAD = 25;
        let CW = GRID_PX + PAD * 2;
        let CH = CW;
        let TURNS_EACH = 8;
        let MAX_RANGE = 4;
        const FLASH_MS = 400;

        const TEAM = { NONE: 0, BLUE: 1, RED: 2, NEUTRAL: 3 };
        const TEAM_RGB = {
            [TEAM.BLUE]:    { r: 59,  g: 130, b: 246 },
            [TEAM.RED]:     { r: 239, g: 68,  b: 68  },
            [TEAM.NEUTRAL]: { r: 168, g: 85,  b: 247 }
        };
        const STR_ALPHA = [0, 30, 58, 98, 153, 208];
        const NEUTRAL_ALPHA = 40;

        /* ===== Quest Mode Config ===== */
        const QUEST_ENEMIES = [
            { id: 'goat', name: 'Goofy Goat', img: 'Images for Quest Mode/Goofy Goat.jpg', difficulty: 'easy', power: 'none', desc: 'No special power', boardSize: 9, turns: 5 },
            { id: 'flamingo', name: 'Foolish Flamingo', img: 'Images for Quest Mode/Foolish Flamingo.jpg', difficulty: 'easy', power: 'shortwords', desc: 'Both players limited to 3-letter words', boardSize: 10, turns: 7 },
            { id: 'hippo', name: 'Hip Hop Hippo', img: 'Images for Quest Mode/Hip Hop Hippo.jpg', difficulty: 'easy', power: 'doubleturn', desc: 'Plays twice between each of your turns', boardSize: 10, turns: 5, aiTurns: 10 },
            { id: 'duck', name: 'Dastardly Duck', img: 'Images for Quest Mode/Dastardly Duck.jpg', difficulty: 'easy', power: 'headstart', desc: 'Starts with 20% of the board already claimed' },
            { id: 'snake', name: 'Sneaky Snake', img: 'Images for Quest Mode/Sneaky Snake.jpg', difficulty: 'medium', power: 'stealth', desc: 'All territory is hidden until the game ends', boardSize: 11, turns: 7 },
            { id: 'turtle', name: 'Tenacious Turtle', img: 'Images for Quest Mode/Tenacious Turtle.jpg', difficulty: 'medium', power: 'superstrength', desc: 'Captures all territory at maximum strength', boardSize: 9, turns: 5 },
            { id: 'raccoon', name: 'Rowdy Raccoon', img: 'Images for Quest Mode/Rowdy Raccoon.jpg', difficulty: 'medium', power: 'shakeup', desc: 'Scrambles the board every 2 turns' },
            { id: 'squirrel', name: 'Stretchy Squirrel', img: 'Images for Quest Mode/Stretchy Squirrel.jpg', difficulty: 'medium', power: 'range', desc: 'Can stretch up to 7 tiles between letters' },
            { id: 'panda', name: 'Petty Panda', img: 'Images for Quest Mode/Petty Panda.jpg', difficulty: 'expert', power: 'splitboard', desc: 'Board is split: each player uses their own half', boardSize: 12 },
            { id: 'penguin', name: 'Professor Penguin', img: 'Images for Quest Mode/Professor Penguin.jpg', difficulty: 'expert', power: 'science', desc: 'Only plays scientific terms (6+ letters)' },
            { id: 'walrus', name: 'Wizardly Walrus', img: 'Images for Quest Mode/Wizardly Walrus.jpg', difficulty: 'expert', power: 'spells', desc: 'Casts 3 powerful spells during battle' }
        ];

        const WALRUS_SPELLS = [
            { id: 'steal', name: 'Territory Steal', desc: 'Steals a chunk of your territory' },
            { id: 'freeze', name: 'Freeze', desc: 'Freezes 5 random cells for 2 turns' },
            { id: 'short', name: 'Short Reach', desc: 'Limits your letter range to 2 tiles next turn' }
        ];

        const SCIENCE_WORDS = new Set([
            'ATOM','CELL','GENE','ION','LAB','DNA','RNA','MASS','BOND',
            'ACID','BASE','VOLT','WATT','LENS','FLUX','SPIN','WAVE',
            'STAR','MOON','MARS','NOVA','CORE','FUSE','HEAT','MELT',
            'TEST','DATA','DOSE','CURE','VEIN','BONE','LUNG','SKIN',
            'FORCE','LIGHT','SOUND','POWER','ENERGY','FIELD','SOLID',
            'FLUID','STEAM','SOLAR','LASER','ORBIT','SPACE','EARTH',
            'BRAIN','HEART','NERVE','PLANT','FUNGI','VIRUS','BLOOD',
            'STEEL','METAL','OXIDE','REACT','PHASE','SCALE','SPEED',
            'MICRO','MACRO','GRAPH','METER','CYCLE','DECAY','PROBE',
            'THETA','SIGMA','GAMMA','DELTA','ALPHA','OMEGA','PRISM',
            'QUARK','BOSON','CHARM','GLUON','MESON','HADRON','LEPTON',
            'PHOTON','PROTON','NEURON','PLASMA','CARBON','OXYGEN',
            'HELIUM','RADIUS','MAGNET','TENSOR','MATRIX','VECTOR'
        ]);

        const API_URL = 'https://api.dictionaryapi.dev/api/v2/entries/en/';
        const API_URL_FALLBACK = 'https://api.datamuse.com/words?sp=';
        let TOTAL_PIXELS = GRID_PX * GRID_PX;

        function recalculateGridSize(size) {
            GRID = size;
            GRID_PX = GRID * CELL;
            CW = GRID_PX + PAD * 2;
            CH = CW;
            TOTAL_PIXELS = GRID_PX * GRID_PX;
        }

        function formatScorePercent(rawPixels) {
            return (rawPixels / TOTAL_PIXELS * 100).toFixed(1) + '%';
        }

        /* ===== Firebase Config ===== */
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyC0XYnCxlRgKnr4f4kCwwvu_eTaiJGfmaI",
            authDomain: "territorywords.firebaseapp.com",
            databaseURL: "https://territorywords-default-rtdb.firebaseio.com",
            projectId: "territorywords",
            storageBucket: "territorywords.firebasestorage.app",
            messagingSenderId: "679952060871",
            appId: "1:679952060871:web:2e75cd252aa2be09e109e2",
            measurementId: "G-QKWSYG60EY"
        };

        let firebaseApp = null;
        let firebaseDB = null;

        function initFirebase() {
            if (firebaseApp) return true;
            try {
                firebaseApp = firebase.initializeApp(FIREBASE_CONFIG);
                firebaseDB = firebase.database();
                return true;
            } catch (e) {
                console.error('Firebase init failed:', e);
                msg('Firebase not configured. Check FIREBASE_CONFIG.');
                return false;
            }
        }

        /* ===== Menu Pixel Art Assets (base64) ===== */
        const MENU_ASSETS = {
            palmTall: 'data:image/png;base64,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',
            palmBend: 'data:image/png;base64,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',
            palmSmall: 'data:image/png;base64,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',
            bushLarge: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAWCAMAAAB5RQVIAAACLlBMVEVHcEwhn4caf20cjHYej3sci3gdjXggh3gdingfl4EbhHAciXUgnocdj3ohoooipIwcinYpyq0ltpsbg3AltpsciXUnvaEejnkhoIggoIoci3Yci3cr1bYekn0ci3cowqYflX8djXgowaUfl4IgmYMgnIUgm4QgmIIek34djHgci3gci3gbg3AnvaIr1LUjr5UflX8af2welH4agW4s2LkpyqwnvaEou58kr5MagG0nvaIZe2kqzrAr0LAafmsbhXIchnMciHMhn4gcinYbhHIjsJYchXIipY0pza8s2Lcou58t370u4sAbhXIt374ipo0biHUiqo8kspgu48IdjngpyqwmuZ0ekn0iqo8qzrAjq5Emu58mv6MipYwkr5YoxKcck3ws17cu48Eltpsr0bIiqpEbhnMdjHgr07QjrJMr1bUnwqUv4sAt2bkciXUhooociXUci3cs2Lgs2bkjqZEhooor0bEiqI8ls5ggp48cinYciHQnvKEch3Mpza8ktZshoIkhpY0jq5IafmwktJkmt5wjrpQchHEr07MbgW4bh3MZfmwjrJMipIwjq5EdlX8jqZAbhHEoxKckspcpzK8fl4EksJcgnYcelH4oxKcagW4elX8r0rMqzq8oxKcqyq0djHgag3Agm4Qq0LEjq5IciXUq0bIox6kgoIgbg28gnIUbhHEbgW8gnocag3Apxagfl4EgnocbhHEaf20fl4EfmYIfmYIaf20gnIUagG0q0LEksJYelX8bhHEgoIgagG0qz7Emup4ox6kpy60luJ0muZ4mvKAbh3MdjnkjrpQmvaEciHQjqpEoxKciqI8pyasagW4dj3oluZ4pzK4ksZYqzq8ktJobg3AbhnIbhXInwqUnwaUmu58r07Qks5kagm8jrZMiqpEfmoMgn4gjr5UcinYnv6Ihoooipo4hpYwafmsfm4QpzK4u4sAdkHokspgmup8djXgltZsr0bIs27ogoYkkrpQmuZ0t3LscjHcmu6AbhnMqza4ZfGonwKMr1rYpyKodjHgnv6MbiHQfl4Abg28gnYUipo0qz7AnvqIfmYIeloAdknwqzrAdkXsoxqkbhXEek30ag3AbhHAgnoYu48Elt5wpyqws17gciXUltZos17cltpskr5Qr1LQnwaQt3r0dj3kmvaIZfmwZeGYr0rIjrJIr0rMs2roiqJAoxKgq0bIhoInYaPjIAAAAjXRSTlMACkYoFCg8HgpPxzLli21anx6zqRSzs9uzs7Oz2xQei6mLUGMe74FZ72SpPGSzn8dk7/kUlVmVbUaf21nHbZ9jZIyV5Xfvs1rRWWPRFKmVgTy9s8fl0dGzqe88bql3s1pZvR7v7+VaqeVQKJ9jvUY8szKVMsezs+/b79G929GVPJ9js4F35Uazd72z2+/vySGdAAACbklEQVQoz42TZVBbURBGlyDB3am7u7u7u7u7e0vd8+LuCQSSACFAcBjcGjRAi3vdnfrjFaZ0mrbZP2fvN2f2x85egD/LKkRhBYaVNamDgaYRJ6CzgapZQI6JgeraHBJGc8s2lv9RPercMA5JeNj+r5LFh7x1AG6kmJP70der50/+MXBZsWAfkBrOSyQHwSGXQNBv2dnbL4ANoTwnfF2D8a3Y07BHx1g4ZaSFHtXkqTbFZFMEcvzCfSlcji6FQ7W6UsFkI31jh9Gy54P4i/AcquLJ4canvuYrBWatjXYdbcyxphNTNXvOkrCYEyG3AUriL0WIw0nK36fZMgYNxhoajS0pygyroVwBuBF/NqqSSJwLY226tf3lDkxywtiV5Zv8jhlTGHcG4Doxno8gfrPGyRh9Wo0doM4EmDl+aD/fRzy5RKShHAHASYvL1YjfmKyg1z8lYwtcE+TI9GlvEiYMJ/inhqcFMyl7AQ5TImmVL/2eRfFXYOZEjrVpE2fEitPvTIXRVBkrg8nXlawBwCt82BVCdjI/db2zM8AqjgAzYRQ3kp5uCyMYj+nKpGh64Dw0kxayiI0EqkhoukURgNsaKHLA1O6Jb4kFAL2pMv/38rthoZPQLKSqqErsLwsUAv6eQvs5fXXzgSZyEQZAF2pZcB6PTCS7oFlcfRQ3ujo3fzPAbo0m27d5BXgf7ose6H2mET5x1KX15B3oT6BU1GoflFWrlgLsZLOCVrasyyeF1x/Fx+CCEqSxhpwB4B33XUSqJHwr3wiwS5UVtLhF7eXYtyeK7QeOebq7O7ocBbh60/OixzUvL9dtaO66fJEdih+0S/b4IHCbyAAAAABJRU5ErkJggg==',
            bushSmall: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAWCAMAAAALimf+AAACMVBMVEVHcEwt3Lwdi3cci3cov58gl38u4L4gh3gcjXggm4MdiXYcinUcjHcci3cgn4Yqz7AjqpIdjXgcjHcekHoci3gdjHgeknwdinYcjnkdj3kci3cu3r0dinYcinYt3bwei3gow6YdiHUdi3cjrpMgm4QluJwou58hooofmoMoxKcksJYoxqkdjXgip48nwqYkr5cqzK4nwaUnwKQnwqYnvqIgj3gnv6IfmIEciXUciHQt27sr1LQciXUci3cciHQci3YcjHcfmYIcinUv5cMfmoMcinYu5MIch3MbhnIdjnkhpIwgnIUu48Ejq5IdkHsiqI8kspgpyqwu4sEgnocgm4QjrJIelX8hoYkfmIEhooofmIIu4sAhpYwpy60oxKcs2Lgu4b8bh3Mv5sQu48IgnoYgn4cciXQjq5Elt5wow6Ynv6IjrZQip44dj3kjr5Ukr5UoxagpyKot374u4cAoxqgbhnMhoYoek34ltpsipo0fm4QhpIsfl4EjqZAiqZAgoIkdj3ou4L4jqZEu5cMek30gnIQekn0fmYMgoIgdknwkspciq5Eeln8ipo4floAhoIgdjHgip48ipYwho4sdjnomup4qz7As2rkt3r0luJ0jrpQlup4oxqkluZ0ekHsmu58r1bUox6kmup8eknwks5ks17gnwaQksJYt3bwhoIkr0rMksZYekXwjrZMt3b0dkXsgn4gch3Qks5gu4L8nv6Mpx6kls5gktJkltJknw6Yt27viWQp/AAAAPHRSTlMAs2Q8CgpGCigURqmB2yjbMh7vZBSpeFCzPJ9G5cepKO9G5e8o7xTv73fb76l3RhSL7+/l7wrv7zyfPJ/EdMdhAAABrklEQVQoz2NgYOByLAuzgQALBgaroCC3ZDdnZ+ekJDYGEOC2c7Kzs0uzsbOxYWDZlVAc5JPsBpRnBEsysKfZ2Li729ltdE+0tC7aXJwQHeTj49bIApFlULRxT/QAgsTS0sD4dTMSiqKjfZqlGWBAZ71fg6fnFM9cvw2x0xbEL42fvkIOLslguil/Vqivb2j28oC4zIWBgbGxq9QQsgy6+Wt9a+ua0rMDsrIy4+YUFGpCxOW1tA2NzEy2+frnVPb6py+ZmTF32eqoVA11ZVUFfqC8QWDh1oIt/jkx1ZMnTQzIWDQ70sbJxsnJ3lYKrF2vpGRnXF5MZH14pFfo/Kl+QH87Obnai0Nt1TfesT0gfGVwSnC/V7grMGSAnlfigDuK1dwxwjvFO8Q7tavH3snextVGhh3JzZxhaxaHtLq4BFf42dra29vaizAgA5V5E8IcHR2r8uxtgcCegwEVSNo61DhGufi72gJ1MjOgA2EHz74Il24HoFYmBkwg5toW5eLl4ODAw4ANSOQ6hrQ7OIgyYAeyEd6d9rw4JBlYvTpahNhxyTJwxpQLMuAGAnwoXADMkHgbRLTjLAAAAABJRU5ErkJggg==',
            grassLarge: 'data:image/png;base64,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',
            grassSmall: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAXCAMAAABd273TAAAC31BMVEVHcEwr07Qr1bYgn4cci3ccjnkci3YdjHglvaAcjHkciHQek30cinUchXEgh3gci3Yci3cluZscjXgot5sciXUcinUag3AdjHgci3Yw6ccqz7Av5cQv6MUt370v4cAmu58bhXIoxacs1rYoxaggoIgox6oluZ0gn4cciXUpyKoqza8di3cdkXss17gq0bEr1bUiqpIpzK4t2rks17cr1bUs2Lgr07Qekn0ltpor1LUnvKAeknst2roow6cdjXgltpoltZonwqUip44ks5khn4ghooonwKMr0rMnv6IhpIwov58bhnIipIwgoIgr1LQr1LYr1LUowqUmu58r1bUkq48ciXUmuZ0jrpQnvqMipY0oxKcnwqUr07Mch3MmvKApxqks2roqzK0bh3QbhnIbhXEbhnIls5oqzK4mvKAnvqMmvaEfmIEZemgks5cltZoZemgbhnIYeWcltJkcg3EjqpEfmoMbhnMbhHEciHQbhXEox6kbgW4cinUdjnoiqI8flH8pyawdinYciXUjq5IjrJIfl4Emt5wmup8ksJYmuZ4ksZcltZslt5sci3Ynv6IoxagbhXInv6Mow6Yci3cs2robg3AmvqIcinYbhXEagW4s2Lcr0rIfmoMq0bIelH4mvKAbhnIagm8px6okr5Upy60ciXUpyqwluJ0jrpQt3r0oxacgm4Qr1LUfl4Abh3MjrZMox6kr1bUr07MnwKQlup4luJwcjHcipY0ho4sdjnkox6oksZciqZAoxKcipo0s2bkr07QdkXsfl4EltpsnwqUhpY0ag3Ar1rYoyKoagm4gnocpyasek3wjrJMq0LEip44pyawdjHgqz7Emup8iqI8v5cMu48EfmIIt3bwoxqgflX8r1bYt3Lsipo4nwaUaf20gnYUmvaEcjXgiqJAjrZQnw6YbhHAls5kt3b0owqYfmIEagW8ktJkoxqkjrpUmu58eloAaf2whooogn4gqza58b5FzAAAAjXRSTlMAs58eKChtHigUn9FaRgrbUB48CjLRgamz71Db74xj25+pPHdG0VAKgZW9i4uLvb0yblmBlW2fvfmpn1oybUbH76mB5VC9gYv57xTl+dFjgW1Gx9sUi+9QlWT5+fm9lZWfWoHb0YtGY/la0e9jKDyV0YHls3dQT8f5Y7Ozd6mzPEZk25Wzs5WBs7PHs+W8F5F5AAACIklEQVQoz32QVVdbURCFNxKSAIUCReru7u7u7u7urtT93hu35saI4VBci5RCkQKBekvdXX5AT1LKQ9ci8zJn7/WtPWcG+FseMYJWcFrR99UdnQItGVE7p0DruIjhToG2D0WjAc7aQG49QAcmYg58dLfW1JfgJkpYivUCwer4ZfOIbN6scZP/iJoEGusEy7HSvARoc+9u01p/vqcnH8NcO2OS8IWbThAE7qtYf/R8EN6iFmjwMs0LGCIbNVaWtPit1B2YljkGUZJw3r/oBbSQAzyKzE9npuulxBj/dHKASvKkbvYiWjgBGKiJzXqjfjZ1CjAuO2WDRDK3DlgopEcCQyMzSpg0aUEicVJTtxS+XwXwJnbv1gng07SQuHnWOEZw+91m8tyqthTe2Ag/g0FDeRM9SKsl1/MqK8qS6vfYM3cpwoy2HVhR85zytev2LDsb2Pnxw02lcj/QaO8nZYbZth2bEnOphnagC3ttBrA7+otMYd8SB3WKsCKjHy8pRS52/HIAy84CtuUxIrbiJDi+gYcUMVXGgH2vi+VdHUC/nOszycFy0z9rcu6EisXexwqyv/7GmczSZA8H0Dc+ypWMNonCfvz8Vio/hcPl+RYDzlZTySMcQH/V48EAV1xiVZqK5RRwoNxSZcPlaqrS3QH0Ual6kEZVlCn1302nAf9fWpkZV63iSh8H0MvFpTdpwUdOHA06HkIW45+7cukCzl8MCSb2H1ymxla4UT1PAAAAAElFTkSuQmCC',
            flowerRed: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAbCAMAAAB7jU7LAAABaFBMVEVHcEzdSU8lup8dk3wgp48gj3/QRUodi3gci3gdi3cmup8iqI8ltZrLQ0mqOD0cjHjfSlDlS1LeSU8ltZvfSlAnwKQlt5wkspgnv6InvqIip4/URkwmvJ8iqZAmvKAkspglt5snvqHYR00kr5UjrpMkr5WPMDQdj3kjrpWRMDQgm4SRMDSSMDSRMDMmt5wekn0djnoek30ekHsdjnkel4AcjXiRMDSTMDSRMDSSMDMmvKAfmYIhn4gou58t3b3eSU+SMDSRMDTdSU8djHgcjHcci3cnv6MmvaHfSk8mup7mTFKQMDQlt5wci3YmvKAnwKPcSE4djXjcSU8ciXUmu58muZ4ltJqkNjojqpEcinYnvqInv6IdjnnbSE6pODysOT0ho4sltpunNzsmup/dSU4ekn0ltZvWTVKuOT6MNTfFWFmfNDmLRUSQLzOeNDgltJkksJYcinUhoYoiqZChNTkeloAdjnogmoSdtSnAAAAAP3RSTlMAlR4yCgrbsxSzs1l3UB48KL13PE+fvfmLgR6pd9tj28c8723vlRT5s9soPGOf74uBUO+p0SiBT71G70blFHdWXcu9AAAA/0lEQVQY003O1XLDMBAF0C06KTMzQ8qMAlNMYS4zM/1+JcsZ+75IZ3auVgAALR2tpml+Y7y1wwRtCKFo9J5gjDmbEPcZ4zYnUEQROmXcdFnLx5cEk3mXFYmTRCpPRBWgkaauaZ6QWUHg3acXsuBxDCH6alkRj/307vH5wZqCcoYyuUnwM5C9nQmwN2MPBtijGxcBdh7psQDr4ppe47NLK8WqfI7ENaOendWCw1eG3dAMUNnexzmRzZ0fJ7vZbXR8DmCxcJNOf3zxSWga4C3pqEXHdovLS/DuKKpa3BUPrYYKiqwqv4eCK2ufiiLLfwfe2vUfmWW//IuNsCSFpT34ByWBMrnNVnqRAAAAAElFTkSuQmCC',
            flowerPurple: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAWCAMAAADHE10VAAABWVBMVEVHcEx4aL8gp48ltZqYg/SeiP2Yg/Mdi3gci3gdi3eTfuyUf+yQfOccjHh6aMIgj3wltZpnWaUjsJVoWaYluJ0mvJ94ld5oWKOdh/yTf+ydh/sjrJIip48jq5JmV6MnvqJOeJ5mWKQmuJ0nw6doWqZnWaZnWaYksplnWaYltJlnWKUdjnkdkXsksZYek30ekXsdj3sdjHgksZcgm4QksJYfl4EcjXgmu58fmYIt3Lwou58hn4idiPydh/xnWaUdjHgci3eeiP1nWKQcjHech/tmWKRnWaZ4Z8BmV6McinUci3YltpscinaYg/ObhvohoIkksZYdjXgkr5UltZoluZ57asUmvaEmup4lt5ydiP1wYbQkspd0ZLtmWKN0ZLpzY7h2Zr5Zo8ZuXrAciXVEjqMluJ0ks5gluZ0ekn1lV6JmV6IiqpEjqZAdjnkgn4ciqI8eloAdjnofmoQ0r0deAAAAPHRSTlMACgoevXf5sxSzZNtQPB4UPMf5PG2BxxRG24upHuWLlduBszxj5alt273R+e/vUKmLgfko0dEo70Z3FOXovt1dAAAA7UlEQVQY003OZVvDMBAH8D8M6IYzXIez4a5JmiZtp9jYhru7fP8XJG2Re3P3e+45AYDqmk176/Di6TE+roRai1BKioK5I5plFiEWSTrMHdVElRJJMsaGPVYQSuiJEG67x0qqZs8EY55Qr2Sdp0STT6jN9OjUGQjYadv2VcppDtjR1XZ509+H32gpHHf/Ca372d5/jJUO8jqX+xy83dtpqANCjT2aifu7bb4bVdXQ2AKw+PxwnU6/6054Aph6zfBcJusNzs1inkvOcyv+osnwizS5/FzzOT3zJqVpfq0HZ5c+TBUbP18sRwwjYqziGzZtKgsA7VZaAAAAAElFTkSuQmCC',
            flowerYellow: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAARCAMAAADaFm2tAAABC1BMVEVHcEz7rkYgp4/moED8sEfChzb0q0Qdi3gci3gdi3clup/DhzgltZoelH4cjXgip48djXknvqH7r0YcjHcdjnkgn4gekXukcy7xqEMdjXgks5odj3ols5kgm4Qnu58kspgjq5EelX+kcy6icS4+hmYkspekci6kdC+ici0mt5shn4gou58t3LsfmYL7r0b6rkYdjHijci4ci3f8sEekcy4cjHekci6jcS4cinX5rkYci3a5gTQcinazfTKhcC3EiDfCiDa/hTWjci35rUa8gzQgnYYek34dkHv4rUX1qkQiqZAipY0djnkkspgciXWodi+dbiwks5kiqI8djXiccS+icC2icS0djnogmoQEcLfrAAAALnRSTlMAlQpQdzLvsxSzHhQ80SgeUDz5ge/vqdu9+W2LgSizbcfvgalQ+eU8Y+/lFHdG5mivqgAAAMVJREFUCNctzedWAjEQhuFP2gKiIlJtKAoqYDbJZgtsARXEQhMQuf8rMdklv+aZOecNACQI0XV9wJgQUkgahBjG8FWIiiIkCXlhltUImVIc2Zb1EPJAf+sRl9ksFOIyRVzbbkU8VGn/d3sXEQVpPwgegZhitffxuVhu7oFs7kQt6rOvW2fdlNPp+RVw+T2ZO85KXdI14Hra517/JyydXeCGm5x7T1G5mC5Rys2/bsR8eWyalO46+4+P3ql87b1wnNG0jPaMf9IeG+xZ0b+UAAAAAElFTkSuQmCC'
        };

        // Weighted letter bag (English frequency approximation)
        const LETTER_BAG =
            'EEEEEEEEEEEEEE' +
            'TTTTTTTTT' +
            'AAAAAAAA' +
            'OOOOOOOO' +
            'IIIIIIII' +
            'NNNNNNN' +
            'SSSSSS' +
            'RRRRRR' +
            'HHHHHH' +
            'LLLL' +
            'DDDD' +
            'CCC' +
            'UUU' +
            'MMM' +
            'WW' +
            'FF' +
            'GG' +
            'YY' +
            'PP' +
            'BB' +
            'VV' +
            'K' +
            'J' +
            'X' +
            'Q' +
            'Z';

        /* ===== AI Word List (~2500 common 3-5 letter words) ===== */
        const AI_WORDS_RAW = 'ace act add age ago aid aim air all ant ape apt arc are ark arm art ash ask ate awe axe bad bag ban bar bat bay bed bet bid big bin bit bog bow box boy bud bug bun bus but buy cab can cap car cat cop cot cow cry cub cup cut dab dad dam day den dew did dig dim dip dog dot dry dub dud due dug dun duo dye ear eat eel egg ego elm emu end era eve ewe eye fab fad fan far fat fax fed fee few fig fin fir fit fix fly foe fog for fox fry fun fur gag gal gap gas gel gem get gig gin god got gum gun gut guy gym had ham has hat hay hen her hew hid him hip his hit hog hop hot how hub hue hug hum hut ice icy ill imp ink inn ion ire ivy jab jag jam jar jaw jay jet jig job jog jot joy jug jut keg ken key kid kin kit lab lad lag lap law lay lea led leg let lid lie lip lit log lot low lug mad man map mar mat maw may men met mid mix mob mod mop mow mud mug mum nab nag nap nay net new nil nip nit nod nor not now nun nut oak oar oat odd ode off oft oil old one opt orb ore our out owe owl own pad pal pan pat paw pay pea peg pen per pet pew pie pig pin pit ply pod pop pot pow pox pro pry pub pug pun pup pus put rag ram ran rap rat raw ray red ref rib rid rig rim rip rob rod rot row rub rug rum run rut rye sac sad sag sap sat saw say sea set sew shy sin sip sir sit six ski sly sob sod son sop sot sow soy spa spy sty sub sue sum sun sup tab tad tag tan tap tar tax tea ten the thy tic tie tin tip tit toe ton too top tot tow toy try tub tug tun two urn use van vat vet vex via vie vim vow wad wag war was wax way web wed wet who why wig win wit woe wok won woo wow yak yam yap yaw yea yes yet yew you zap zed zen zip zoo able ache acid acre aged aide ally also arch area army aunt auto away axle back bait bake bald bale ball band bane bang bank bare bark barn base bass bath bead beak beam bean bear beat beef been beer bell belt bend best bias bike bile bill bind bird bite blow blue blur boar boat body bold bolt bomb bond bone book boom boot bore born boss both bout bowl braid bulk bull bump burn bury bush busy cafe cage cake calf call calm came camp cane cape card care cart case cash cast cave cell chat chef chin chip cite city clad clam clan clap claw clay clip clod clog club clue coal coat code coil coin cold colt comb come cone cook cool cope copy cord core cork corn cost cosy coup cove cozy crab crew crop crow cube cult curb cure curl cute dale damp dare dark darn dart dash data date dawn dead deaf deal dear deck deed deem deep deer defy deli deny desk dial dice diet dime dine dire dirt disc dish disk dock does dome done doom door dose dove down doze drab drag draw drew drip drop drum dual duck duct dude duel duet duke dull dumb dump dune dung dunk dupe dusk dust duty each earl earn ease east easy edge edit else emit envy epic even ever evil exam exit eyes face fact fade fail fair fake fall fame fang fare farm fast fate fawn fear feat feed feel feet fell felt fend fern file fill film find fine fire firm fish fist five flag flaw flea fled flee flew flip flit flock flog flow flue flux foam foil fold folk fond font food fool foot ford fore fork form fort foul four fowl free frog from fuel full fume fund funk fury fuse fuss gait gale gall game gang gape gash gasp gate gave gaze gear gene germ gift gild gill gist give glad glee glen glib glob glom glow glue glut gnat gnaw goat goes gold golf gone good gore gory gown grab gray grew grid grim grin grip grit grow grub gulf gull gulp gush gust guts gaze hack hail hair hale half hall halt hand hang hare hark harm harp hash haste hate haul have haze head heal heap hear heat heed heel held hell help herb herd here hero hide high hike hill hilt hind hint hire hold hole holy home hone hood hook hope horn hose host hour howl huff huge hull hump hung hunt hurl hurt husk hymn idea inch info into iron isle itch item jack jade jail jamb jape java jazz jeer jest jilt jive jobs jock john join joke jolt jury just kale keen keep kelp kept kick kind king kite knack knee knew knit knob knot know lace lack lade lady laid lake lame lamp land lane lard lark lash lass last late lawn lead leaf leak lean leap left lend lens less lick lien lieu life lift like limb lime limp line link lion list live load loaf loam loan lock lode loft logo lone long look loom loop lore lorn lose loss lost loud love luck lull lump lung lure lurk lush lust mace made maid mail main make male mall mane many mare mark mash mask mass mast mate math maze mead meal mean meat meet meld melt memo mend menu mere mesh mess mild mile milk mill mime mind mine mint mire miss mist mite moan moat mock mode mold mole molt monk mood moon moor more morn moss most moth move much muck mule mull murk muse mush must mute myth nail name nape navy near neat neck need nest news next nice nick nine node none noon norm nose note noun nude null oath obey odds okay omen omit once only onto opal open opts oral orca over owed oxen pace pack pact page paid pail pain pair pale palm pane pang pare park part pass past path pave pawn peak peal pear peat peck peek peel peer pelt pend perk pest pick pier pike pile pine pink pint pipe pith plan play plea plod plot plow ploy plug plum plus pock poem poet poke pole poll polo pond pony pool pope pore pork port pose post pour pray prep prey prod prop prude prune puck pull pulp pump punk pure push race rack raft rage raid rail rain rake ramp rang rank rant rash rasp rate rave raze read real ream reap rear reed reef reel rein rely rend rent rest rice rich ride rift rill rime rind ring riot rise risk road roam roar robe rock rode role roll roof room root rope rose rosy rout rove ruin rule rump rung ruse rush rust sack safe sage said sail sake sale salt same sand sane sang sank sash save scan scar seal seam sear seat sect seed seek seem seen self sell send sent sept shed shin ship shop shot show shut sick side sift sigh sign silk sill silt sing sink site size skit slab slag slam slap slat slaw slay sled slew slid slim slit slob slop slot slow slug slum slur smog snap snag snare snip snob snot snow snub soak soap soar sock soil sold sole some song soon soot sore sort soul sour span spar spec sped spin spit spot spry spur stab stag star stay stem step stew stir stop stow stub stud stun such suit sulk sump sung sunk sure surf swan swap swat sway swim swum tack tact tail take tale talk tall tame tang tank tape taps tart task taxi teak teal team tear tell tend tent term test text than that them then thin this thud thus tick tide tidy tier tile till tilt time tine tiny tire toad toil told toll tomb tone took tool tops tore torn toss tour town trap tray tree trek trim trio trip trod trot true tube tuck tuft tuna tune turf turn tusk twin type ugly undo unit unto upon urge used user vain vale vane vary vase vast veil vein vent verb very vest veto vial vice view vine visa void volt vote wade wage wail wait wake walk wall wand want ward warm warn warp wart wary wash vast wave wavy waxy weak wean wear weed week well welt went were west what when whim whip whom wick wide wife wild will wilt wily wind wine wing wink wipe wire wise wish wisp with woke wolf womb wood wool word wore work worm worn wove wrap wren wrist writ yarn yawn year yell yelp yoga yolk your zeal zero zest zinc zone zoom abate abbey abhor abide abort about above abuse occur ocean abyss acute adapt admit adopt adult after again agent agile aging agree aided aimer aisle alarm album alert algae alibi alien align alike alive allay alley allot allow alloy aloft alone along aloof alpha altar amaze ample amuse angel anger angle angry anime ankle annex anvil apart apple apply apron arena argue arise armor aroma arose array arrow aside asset atlas attic audio audit avail await awake award aware awful axiom bacon badge badly baker baron basal basic basin basis batch beach beard beast began begin being below bench berry birth black blade blame blank blast blaze bleed blend bless blind blink bliss block blond blood bloom blown board boast bonus boost booth bound brace brain brand brass brave bread break breed brick bride brief bring brink broad broke broom brown brush buddy build built bunch burst buyer cabin cable camel candy cargo carry carve catch cater cause cease chain chair chalk champ chaos charm chart chase cheap check cheek cheer chess chest chick chief child chill china choir chord chose chunk churn civic claim clamp clash clasp class clean clear clerk cliff climb cling clock clone close cloth cloud clown coach coast color comet comic coral count court cover crack craft crane crash crawl crazy cream creed creek crest crime crisp cross crowd crown crude crush curve cycle daily dance debut decal decay decoy decoy delta dense depot depth derby devil diary dirty disco ditch dodge doing donor doubt dough draft drain drake drama drank drape drawn dread dream dress dried drift drill drink drive drone drown drove drugs drunk dryer dying eager eagle early earth eight elder elect elite email ember empty endow enemy enjoy enter entry equal equip erase error essay evade event every exact exalt exam exile exist extra faint fairy faith false fault feast fiber field fifth fifty fight final first flame flash fleet flesh float flock flood floor flora flour fluid flush focus force forge forth forum fossil found frame frank fraud fresh front frost froze fruit fully funny ghost giant given glade glare gleam glide globe gloom glory glove going grace grade grain grand grant grape grasp grass grave great greed green greet grief grill grind gripe groan groom gross group grove grown guard guess guest guide guild guilt guise gulch gully habit happy harsh hasn haste haven heard heart heavy hence hobby homer honey honor horse hotel house human humor hurry hyper ideal image imply incur index indie infer inner input inter intro issue ivory jewel joint joker judge juice jumbo juror juicy kebab knack kneel knelt knife knock known label labor lance large laser latch later laugh layer leach learn lease leave legal lemon level lever light limit linen liver local lodge logic loose lover lower loyal lucky lunar lunch maker manor maple march marry match mayor media mercy merit metal meter might minor minus model money month moral motor mount mouse mouth moved movie music naive nerve never night noble noise north noted novel nurse nylon ocean offer often olive onset opera orbit order organ other ought outer owned oxide padre paint panel panic paper party paste patch pause peach pearl pedal penny phase phone photo piano piece pilot pitch pixel pizza place plain plane plant plate plaza plead pluck plumb plume plump plunge point polar pound power press price pride prime print prior prize probe prone proof proud prove proxy psalm pupil purse queen quest quick quiet quite quota quote radar radio raise rally ranch range rapid ratio reach react ready realm rebel reign relax relay renew reply rider ridge rifle right rigid rival river robot rocky rouge rough round route royal rugby ruler rural sadly saint salad sauce scale scare scene scent scope score scout scrap sense seize serve setup seven shade shaft shake shall shame shape share shark sharp sheer sheet shelf shell shift shine shirt shock shoot shore short shout shown sight silly since sixth sixty sized skate skill skull slant slate slave sleep slice slide slope smart smell smile smoke snake solar solid solve sorry sound south space spare spark speak speed spend spent spike spine spite split spoke spoon sport spray squad stack staff stage stain stake stall stamp stand stare start state stays steal steam steel steep steer stern stick stiff still stock stole stone stood stool store storm story stove strap straw stray strip spoke stuck study stuff style sugar suite sunny super surge swamp swear sweep sweet swept swift swing sword swore swung table taken taste taxes teach teeth tempo theft theme there thick thing think third those three threw throw thumb tiger tight timer tired title today token topic total touch tough tower toxic trace track trade trail train trait trash treat trend trial trick troop truck truly trump trunk trust truth tumor twice twist tying ultra uncle under unify union unite unity until upper upset urban usage usual utter valid value valve vault verse video vigor vinyl viral virus visit vital vivid vocal voice voter wagon waste watch water weary weave wedge weigh weird whale wheat wheel where which while white whole whose widen width wield woman woods world worry worse worst worth would wound wrath write wrote yield young yours youth';

        let AI_WORD_SET = null;
        let AI_PREFIX_SET = null;

        function buildAIWordSets() {
            if (AI_WORD_SET) return;
            AI_WORD_SET = new Set(AI_WORDS_RAW.split(' ').map(w => w.toUpperCase()));
            AI_PREFIX_SET = new Set();
            for (const w of AI_WORD_SET) {
                for (let i = 1; i <= w.length; i++) {
                    AI_PREFIX_SET.add(w.substring(0, i));
                }
            }
        }

        /* ===== Professor Penguin: science-only word set (6+ letter single words) ===== */
        let PENGUIN_WORD_SET = null;
        let PENGUIN_PREFIX_SET = null;

        function buildPenguinWordSets() {
            if (PENGUIN_WORD_SET) return;
            const allTerms = [
                'ABASIA','ABDOMEN','ABERRANT','ABERRATION','ABIOGENESIS','ABNORMAL','ABORIGINES',
                'ABORT','ABSOLUTE','ABSORPTION','ABSTRACT','ABULIA','ABYSSAL','ACAULESCENT',
                'ACCELERATION','ACCIDENT','ACHENE','ACHROMATIC','ACID','ACTINIUM','ACTINOZOAN',
                'ACULEATE','ACUMINATE','ADIABATIC','ADRENALIN','ADSORPTION','ADVENTITIOUS',
                'AERIAL','AFFECT','AFFERENT','AGORAPHOBIA','AGRONOMICS','AGROSTOLOGY',
                'ALBINO','ALBUMEN','ALBUMIN','ALCOHOL','ALKALI','ALLOTROPY','ALLOY','ALLUVIUM',
                'ALPINE','ALUMINIUM','AMALGAM','AMMETER','AMORPHOUS','AMPERE','AMPHIBIA',
                'AMPLEXICAUL','ANABOLISM','ANALOGY','ANALYSIS','ANANDROUS','ANAPHYLAXIS',
                'ANATOMY','ANEMOGRAPH','ANGIOSPERM','ANHYDROUS','ANIMAL','ANIMALCULE','ANION',
                'ANNUAL','ANNULATE','ANNULATED','ANODE','ANTENNA','ANTHER','ANTHROPOGEOGRAPHY',
                'ANTHROPOLOGY','ANTICLINAL','ANTICYCLONE','ANTIDOTE','ANTIMONY',
                'APETALOUS','APHASIA','APHELION','APHELIOTROPIC','APOGEE','APONEUROSIS',
                'AQUATIC','ARACHNIDA','ARACHNOID','ARBOREAL','ARCHEOLOGY','ARCHEAN',
                'ARENICOLOUS','ARGON','ARSENIC','ARTICULATION','ASCENDANT','ASEXUAL',
                'ASSAY','ASSOCIATION','ASTEROID','ASTRONOMY','ASTROPHYSICS','ATMOSPHERE',
                'AURORA','AXIOM','BACILLUS','BACTERIUM','BARBARIAN','BARIUM','BAROMETER',
                'BATRACHIA','BATTERY','BEHAVIORISM','BICHLORIDE','BIENNIAL','BINARY',
                'BIOCHEMISTRY','BIOLOGY','BIOPHORE','BISEXUAL','BISMUTH','BORON','BOTANY',
                'BRACHYCEPHALIC','BROMINE','BRONZE','CADMIUM','CAESIUM','CALCIUM','CALCULUS',
                'CALORIE','CALORIMETER','CALYX','CAMBRIAN','CANDLEPOWER','CAPILLARITY',
                'CAPITAL','CARBON','CARBONIFEROUS','CARBURETOR','CARBURETTOR','CARDIO',
                'CARINA','CARNIVORA','CARPEL','CATABOLISM','CATALYSIS','CAUDAL','CAUSE',
                'CELSIUS','CENOGETIC','CENOZOIC','CENTIGRADE','CENTIMETER','CENTRIFUGAL',
                'CENTRIPETAL','CENTROSOME','CENTRUM','CEPHALIC','CEPHALOPODA','CEREAL',
                'CERIUM','CETACEA','CHEMISTRY','CHIROPTERA','CHLORIDE','CHLORINE',
                'CHLOROPHYLL','CHROMIUM','CHROMO','CHROMOSOME','CIVILIZATION','CLIMATE',
                'COBALT','COCCUS','COELENTERATA','COHESION','COLLOID','COLUMBIUM','NIOBIUM',
                'COMBUSTION','COMMUNITY','COMPARATIVE','COMPLEX','COMPOUND','CONATION',
                'CONCAVE','CONCEPT','CONCEPTION','CONDENSE','CONDUCT','CONDUCTANCE',
                'CONDUCTIVITY','CONDUCTOR','CONGEAL','CONNATE','CONSTANT','CONVEX',
                'COORDINATE','COPERNICAN','COPPER','COROLLA','CORONA','COTYLEDON','COULOMB',
                'CRETACEOUS','CRIMINOLOGY','CRUSTACEA','CRYSTAL','CTENOPHORA','CYCLONE',
                'CYTOPLASM','DARWINISM','DECLINATION','DECURRENT','DEHYDRATE','DENDROLOGY',
                'DEVONIAN','DIADELPHOUS','DIANDROUS','DIELECTRIC','DISEASE','DISSOCIATE',
                'DOLDRUMS','DOLICHOCEPHALIC','DYNAMICS','ECCENTRIC','ECHINODERM','ECLIPSE',
                'ECLIPTIC','ECOLOGY','ECONOMICS','EDENTATE','EFFECT','EFFERENT','EFFICIENCY',
                'EFFLORESCENCE','ELECTRICITY','ELECTRODE','ELECTROLYSIS','ELECTROLYTE',
                'ELECTRON','ELEMENT','EMANATION','EMBRYO','ENDOGENOUS','ENDOSPERM',
                'ENDOTHELIUM','ENERGY','ENTOMOLOGY','ENVIRONMENT','EOCENE','EPIPHYTE',
                'EQUATION','EQUINOX','ERBIUM','EROSION','ESTHETICS','AESTHETICS','ETHER',
                'ETHICS','ETHNOLOGY','EUROPIUM','EVAPORATE','EVERGREEN','EVOLUTION',
                'EXPERIMENT','EXPLAIN','FACTOR','FACULA','FAHRENHEIT','FECUNDATE','FEMALE',
                'FERMENT','FILAMENT','FLOCCULUS','FLORESCENCE','FLOWER','FLUORESCENCE',
                'FLUORINE','FORECONSCIOUS','FORENSIC','FORMULA','FOSSIL','FREEZE','FRICTION',
                'FULCRUM','FUNCTION','FUNCTIONAL','FUNGUS','GADOLINIUM','GALLIUM','GAMETE',
                'GANGLION','GASTROPODA','GENERALIZATION','GENETICS','GENITAL','GEOGRAPHY',
                'GEOLOGY','GERMANIUM','GLACIER','GLOMERATE','GLOTTIS','GLUCINUM','BERYLLIUM',
                'GLUCOSE','GNEISS','GRAVITY','GRAVITATION','GREGARIOUS','GYMNOSPERM',
                'HALLUCINATION','HARDNESS','HELIUM','HERMAPHRODITE','HERPETOLOGY','HEXAPODA',
                'HINTERLAND','HISTOLOGY','HISTORY','HOLMIUM','HOMOLOGY','HORMONE',
                'HUMIDITY','HURRICANE','HYBRID','HYDRATE','HYDRAULICS','HYDROCARBON',
                'HYDROGEN','HYDROLYSIS','HYDROMETER','HYDROSTATICS','HYDROUS','HYDROZOAN',
                'HYGIENE','HYGROMETRY','HYPOTHESIS','IGNEOUS','INDEHISCENT','INDIUM',
                'INDUCTANCE','INERTIA','INFLORESCENCE','INFUSORIA','INORGANIC','INSECT',
                'INSTINCT','INTERFERENCE','INVERTEBRATE','IODINE','IRIDIUM','ISOBAR',
                'ISOTHERM','JURASSIC','KIDNEY','KILOGRAM','KRYPTON','LABILE','LANTHANUM',
                'LEUCOCYTE','LITHIUM','LITMUS','LUTECIUM','MAGNESIUM','MAGNETIZE','MAMMAL',
                'MANDIBLE','MANGANESE','MARSUPIAL','MATHEMATICS','MATTER','MECHANICS',
                'MEDICINE','MEGACEPHALIC','MERCURY','MESOZOIC','METABOLISM','METAPHYSICS',
                'METAZOA','MICROBE','MINERAL','MINERALOGY','MIOCENE','MITOSIS','MIXTURE',
                'MOLECULE','MOLYBDENUM','MOMENTUM','MONADELPHOUS','MONILIFORM','MONECIOUS',
                'MONOPOLY','MONOTREME','MONSOON','MORAINE','MORPHOLOGY','MUSCLE','MUSCOLOGY',
                'MUTATION','MYCOLOGY','MYRIAPODA','NARCOTIC','NASCENT','NEBULAR','NECTAR',
                'NEOCENE','NEODYMIUM','NEOLITHIC','NEUROSIS','NEUTRAL','NICKEL','NITROGEN',
                'NORMAL','NUTRITIVE','OLIGOCENE','ONTOGENY','OPSONIC','OPTICS','OPTIMUM',
                'ORDOVICIAN','ORGANIC','ORGANISM','OSMIUM','OVERTONE','OXIDIZE','OXYGEN',
                'PALEOZOIC','PALEONTOLOGY','PALLADIUM','PARALLAX','PARALOGY','PARASITE',
                'PARTHENOGENESIS','PELAGIAN','PELAGIC','PENOLOGY','PERENNIAL','PHAGOCYTE',
                'PHENOMENON','PHENOMENA','PHILOLOGY','PHILOSOPHY','PHONOLOGY','PHOSPHORUS',
                'PHOTICS','PHOTOLOGY','PHYLUM','PHYSICS','PISTIL','PLANET','PLATINUM',
                'PLEISTOCENE','POLLEN','POLLINATION','POLONIUM','POTASSIUM','POUNDAL',
                'PRACTICE','PRASEODYMIUM','PRECIPITATE','PREHENSILE','PRESSURE','PRIMATE',
                'PROPERTY','PROTEAN','PROTEID','PROTEIN','PROTOPLASM','PROTOZOAN','PSEUDO',
                'PSYCHIATRY','PSYCHOLOGY','PSYCHOPHYSICS','PSYCHOSIS','PTERIDOPHYTE',
                'QUANTEL','QUANTITY','QUANTUM','QUATERNARY','RADICAL','RADICLE','RADIOACTIVE',
                'RADIUM','RAREFACTION','REACT','REACTION','REAUMUR','RECENT','RECTIFY',
                'REDUCE','REFRACT','RELATIVITY','REPRODUCTION','REPTILE','RESISTANCE',
                'RHODIUM','RODENT','RUBIDIUM','RUMINANT','RUTHENIUM','SAMARIUM','SAPONIFY',
                'SATURATE','SCANDIUM','SCIENCE','SECONDARY','SELENIUM','SEMINAL',
                'SEMINIFEROUS','SENSATION','SENTIMENT','SEPTUM','SESSILE','SHEATH',
                'SILICON','SILVER','SIMOOM','SIMPLE','SOCIAL','SOCIOLOGY','SODIUM',
                'SOLUTION','SOMATIC','SPECIES','SPECTRUM','SPERMARY','SPOROZOAN',
                'STAMEN','STATICS','STATISTICS','STIGMA','STIPULE','STRATUM','STRONTIUM',
                'SUBALPINE','SUBLIMATION','SULPHUR','SUPERSTITION','SYMBOL','SYNCLINAL',
                'SYNTHETIC','TANTALUM','TELLURIUM','TEMPERATURE','TENDON','TERBIUM',
                'TERTIARY','THALLIUM','THALLOPHYTE','THALLUS','THEOLOGY','THEORY','THERMO',
                'THORAX','TINCTURE','TITANIUM','TRIASSIC','TYPHOON','ULOTRICHI','UNGULATE',
                'URANIUM','VACUUM','VANADIUM','VELOCITY','VERTEBRATE','VITALISM','VITAMINES',
                'VOLUME','WEIGHT','XENON','XYLOGY','YTTRIUM','ZIRCONIUM','ZOOCHEMISTRY',
                'ZOOLOGY','ZYGOTE','ZYMOSIS','ZYMURGY'
            ];
            PENGUIN_WORD_SET = new Set();
            PENGUIN_PREFIX_SET = new Set();
            for (const w of allTerms) {
                if (w.length >= 6) {
                    PENGUIN_WORD_SET.add(w);
                }
            }
            for (const w of PENGUIN_WORD_SET) {
                for (let i = 1; i <= w.length; i++) {
                    PENGUIN_PREFIX_SET.add(w.substring(0, i));
                }
            }
        }

        /* ===== Extra valid words (common words missing from AI list) ===== */
        const EXTRA_VALID_WORDS_RAW = 'their these could would which where every being after other first about should there under great still never right think house world place found might while small water since light night again large group often until along white young those point might state three given start early begin order might under thing write whole shall women later heart story watch below leave close going build carry plant might bring paper might learn above cross serve study cover words might might table north south might human power field party class light water might music offer drive stand image money might hotel lives space force known black moral might mouth final write point taken whose sound basis exist union could extra valid queen';
        let VALID_WORD_SET = null;

        function buildValidWordSet() {
            if (VALID_WORD_SET) return;
            buildAIWordSets();
            VALID_WORD_SET = new Set(AI_WORD_SET);
            for (const w of EXTRA_VALID_WORDS_RAW.split(' ')) {
                VALID_WORD_SET.add(w.toUpperCase());
            }
        }

        /* ===== Tutorial board (11x11) ===== */
        const TUTORIAL_GRID = [
            ['H','A','T','S','E','N','D','I','T','O','N'],
            ['O','N','E','R','A','N','G','E','S','T','H'],
            ['W','O','R','D','S','C','O','R','E','I','S'],
            ['S','T','R','O','N','G','H','O','L','D','S'],
            ['P','L','A','Y','L','E','T','T','E','R','S'],
            ['O','I','N','T','S','C','A','P','T','U','R'],
            ['I','N','T','O','A','R','E','A','S','N','O'],
            ['N','E','X','T','T','U','R','N','G','O','W'],
            ['T','I','L','E','S','P','A','N','E','L','S'],
            ['S','E','T','U','P','W','O','R','D','S','A'],
            ['T','H','I','S','I','S','F','U','N','O','K']
        ];

        /* ===== Tutorial steps ===== */
        const TUTORIAL_STEPS = [
            {
                title: 'Welcome to Word Conquest!',
                desc: 'In this game, you spell words by selecting letters on the grid. The letters you pick form a polygon that captures territory. Let\'s learn how it works!',
                action: 'next',
                highlights: []
            },
            {
                title: 'Step 1: Select Your First Letter',
                desc: 'Click the letter <b>H</b> at the top-left corner of the board.',
                action: 'click',
                highlights: [{r:0, c:0}],
                target: {r:0, c:0}
            },
            {
                title: 'Step 2: Spell HELP',
                desc: 'Now click <b>E</b> at (row 0, col 4), then <b>L</b> at (row 4, col 4), then <b>P</b> at (row 4, col 0) to spell "HELP". Each letter is exactly distance 4 from the last \u2014 the maximum range!',
                action: 'click',
                highlights: [{r:0, c:4}, {r:4, c:4}, {r:4, c:0}],
                targets: [{r:0, c:4}, {r:4, c:4}, {r:4, c:0}]
            },
            {
                title: 'Step 3: Submit & Capture Territory',
                desc: 'See the dashed line closing the polygon? These four letters form a large square. Click <b>Submit Word</b> to capture all that territory!',
                action: 'submit',
                highlights: []
            },
            {
                title: 'Step 4: Letters Disappear',
                desc: 'Notice that H, E, L, P have <b>vanished</b> from the board! Used letters are consumed after each word. Plan carefully \u2014 letters are a limited resource.',
                action: 'next',
                highlights: []
            },
            {
                title: 'Step 5: Strength, Overlap & Scoring',
                desc: 'Longer words have higher <b>strength</b>. Overlapping enemy territory subtracts theirs. Your score is the <b>percentage</b> of the board you control.',
                action: 'next',
                highlights: []
            },
            {
                title: 'You\'re Ready!',
                desc: 'You now know the basics of Word Conquest. Spread your letters wide for big territory, spell longer words for higher strength, and contest your opponent\'s land. Have fun!',
                action: 'done',
                highlights: []
            }
        ];

        /* ===== State ===== */
        let grid = [];
        let player = 'blue';
        let sel = [];
        let tOwner, tStrength;
        let turnsLeft = { blue: TURNS_EACH, red: TURNS_EACH };
        let gameOver = false;
        let submitting = false;
        let networkError = false;
        let msgTimer = null;
        let hoverCell = null;
        let history = [];
        let soundOn = false;

        // Game mode
        let gameMode = 'pvp'; // 'pvp' | 'pvc' | 'tutorial'

        // Options state
        let aiDifficulty = 'medium'; // 'easy' | 'medium' | 'expert'
        let timerEnabled = false;
        let timerDuration = 0;
        let boardSize = 11; // 9, 10, 11, 12, 13
        let turnTimerRemaining = 0;
        let turnTimerInterval = null;

        // AI state
        let aiThinking = false;

        // Flash animation state
        let flashCvs, flashCtx;
        let flashStart = 0;
        let flashing = false;

        // Particle system
        let particles = [];

        // Floating score text
        let floatingTexts = [];

        // Animated score counters
        let displayedScoreBlue = 0;
        let displayedScoreRed = 0;
        let animatingScores = false;
        let scoreAnimStartTime = 0;
        let scoreAnimStartBlue = 0;
        let scoreAnimStartRed = 0;
        let scoreAnimTargetBlue = 0;
        let scoreAnimTargetRed = 0;

        // Tutorial state
        let tutorialStep = 0;
        let tutorialActive = false;
        let tutorialTargetIndex = 0; // index into current step's targets array

        // Online multiplayer state
        let onlineMode = false;
        let onlineRole = null; // 'host' | 'guest'
        let onlineGameRef = null;
        let onlineGameCode = '';
        let onlineListeners = [];
        let onlineMoveCount = 0;

        // Quest mode state
        let questMode = false;
        let questEnemyIndex = 0;
        let questProgress = JSON.parse(localStorage.getItem('questProgress') || '[]');
        let questTurnCount = 0;
        let questFrozenCells = [];    // [{r,c,turnsLeft}]
        let questWalrusSpellsUsed = 0;
        let questWalrusSpellOrder = []; // shuffled spell ids assigned to turns 3, 5, 7
        let questWalrusDoubleNext = false;
        let questHippoFirstTurn = false; // true when Hippo is on first of two turns
        let questPlayerShortRange = false; // true when player's range is limited to 2
        let questSnakeMoves = [];  // [{path, player, strength}] recorded moves for stealth reveal
        let questSnakeRevealing = false; // true during end-of-game territory reveal
        let shakeupAnim = null; // {moves: [{letter, fromX, fromY, toX, toY}], startTime, duration}

        /* ===== Canvas refs ===== */
        let cvs, ctx;
        let tCvs, tCtx;

        /* ===== Audio ===== */
        let audioCtx = null;

        function getAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
            return audioCtx;
        }

        function playSound(type) {
            if (!soundOn) return;
            const ac = getAudio();
            const t = ac.currentTime;

            function tone(freq, start, dur, vol, wave) {
                const o = ac.createOscillator();
                const g = ac.createGain();
                o.type = wave || 'sine';
                o.frequency.value = freq;
                g.gain.setValueAtTime(vol, t + start);
                g.gain.exponentialRampToValueAtTime(0.001, t + start + dur);
                o.connect(g);
                g.connect(ac.destination);
                o.start(t + start);
                o.stop(t + start + dur);
            }

            switch (type) {
                case 'select':
                    tone(800, 0, 0.06, 0.1);
                    break;
                case 'accept':
                    tone(523, 0, 0.15, 0.1);
                    tone(784, 0.12, 0.2, 0.12);
                    break;
                case 'reject':
                    tone(200, 0, 0.25, 0.08, 'sawtooth');
                    break;
                case 'gameend':
                    tone(523, 0, 0.3, 0.1);
                    tone(659, 0.15, 0.3, 0.1);
                    tone(784, 0.30, 0.3, 0.1);
                    tone(1047, 0.45, 0.5, 0.12);
                    break;
            }
        }

        function toggleSound() {
            soundOn = !soundOn;
            document.getElementById('sound-toggle').textContent =
                soundOn ? 'Sound: ON' : 'Sound: OFF';
            if (soundOn) playSound('select');
        }

        /* ===== Online Multiplayer ===== */
        function generateGameCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 6; i++) code += chars[Math.floor(Math.random() * chars.length)];
            return code;
        }

        function showOnlineScreen() {
            if (!initFirebase()) return;
            document.getElementById('online-screen').classList.remove('hidden');
            document.getElementById('join-code-input').value = '';
        }

        function hideOnlineScreen() {
            document.getElementById('online-screen').classList.add('hidden');
        }

        function isMyTurn() {
            if (!onlineMode) return true;
            const myColor = onlineRole === 'host' ? 'blue' : 'red';
            return player === myColor;
        }

        async function createOnlineGame() {
            if (!initFirebase()) return;
            const code = generateGameCode();
            onlineGameCode = code;
            onlineRole = 'host';

            // Read current options
            const turnsInput = document.getElementById('opt-turns');
            const turnsVal = parseInt(turnsInput.value, 10);
            const gameTurns = (isNaN(turnsVal) || turnsVal < 1 || turnsVal > 20) ? 8 : turnsVal;

            onlineGameRef = firebaseDB.ref('games/' + code);

            const gameData = {
                status: 'waiting',
                host: 'connected',
                guest: null,
                boardSize: boardSize,
                turnsEach: gameTurns,
                timerEnabled: timerEnabled,
                grid: null,
                currentPlayer: 'blue',
                turnsLeft: { blue: gameTurns, red: gameTurns },
                moveCount: 0,
                lastMove: null,
                createdAt: firebase.database.ServerValue.TIMESTAMP
            };

            try {
                await onlineGameRef.set(gameData);
            } catch (e) {
                console.error('Failed to create game:', e);
                msg('Failed to create game. Check Firebase config.');
                onlineGameRef = null;
                onlineRole = null;
                return;
            }

            // Set up disconnect handler
            onlineGameRef.child('host').onDisconnect().set('disconnected');

            // Hide online screen, show lobby
            hideOnlineScreen();
            document.getElementById('lobby-code-display').textContent = code;
            document.getElementById('lobby-status').innerHTML = '<span class="dot"></span> Waiting for opponent...';
            document.getElementById('lobby-screen').classList.remove('hidden');

            // Listen for guest joining
            const guestRef = onlineGameRef.child('guest');
            const guestListener = guestRef.on('value', (snap) => {
                if (snap.val() === 'connected') {
                    document.getElementById('lobby-status').innerHTML = '<span class="dot" style="background:#34d399"></span> Opponent joined! Starting...';
                    setTimeout(() => startOnlineGame(), 800);
                }
            });
            onlineListeners.push({ ref: guestRef, event: 'value', callback: guestListener });
        }

        async function joinOnlineGame() {
            if (!initFirebase()) return;
            const input = document.getElementById('join-code-input');
            const code = input.value.toUpperCase().trim();
            if (code.length !== 6) {
                msg('Enter a 6-character game code.');
                return;
            }

            const gameRef = firebaseDB.ref('games/' + code);
            let snap;
            try {
                snap = await gameRef.once('value');
            } catch (e) {
                msg('Failed to connect. Check Firebase config.');
                return;
            }

            if (!snap.exists()) {
                msg('Game not found. Check the code.');
                return;
            }

            const data = snap.val();
            if (data.status !== 'waiting') {
                msg('Game already started or finished.');
                return;
            }
            if (data.guest === 'connected') {
                msg('Game is full.');
                return;
            }

            onlineGameCode = code;
            onlineRole = 'guest';
            onlineGameRef = gameRef;

            // Set guest as connected
            await onlineGameRef.child('guest').set('connected');
            onlineGameRef.child('guest').onDisconnect().set('disconnected');

            // Hide online screen, show brief lobby
            hideOnlineScreen();
            document.getElementById('lobby-code-display').textContent = code;
            document.getElementById('lobby-status').innerHTML = '<span class="dot" style="background:#34d399"></span> Connected! Starting...';
            document.getElementById('lobby-screen').classList.remove('hidden');

            // Listen for game to start (host sets grid)
            const gridRef = onlineGameRef.child('grid');
            const gridListener = gridRef.on('value', (snap) => {
                if (snap.val()) {
                    startOnlineGame();
                }
            });
            onlineListeners.push({ ref: gridRef, event: 'value', callback: gridListener });
        }

        let onlineGameStarted = false;
        async function startOnlineGame() {
            if (onlineGameStarted) return;
            onlineGameStarted = true;
            // Remove lobby listeners
            for (const l of onlineListeners) {
                l.ref.off(l.event, l.callback);
            }
            onlineListeners = [];

            // Hide lobby and online screens
            document.getElementById('lobby-screen').classList.add('hidden');
            document.getElementById('online-screen').classList.add('hidden');
            document.getElementById('menu-screen').classList.add('hidden');

            onlineMode = true;
            gameMode = 'online';
            onlineMoveCount = 0;

            // Load settings from Firebase
            const snap = await onlineGameRef.once('value');
            const data = snap.val();

            const remoteBoardSize = data.boardSize || 11;
            TURNS_EACH = data.turnsEach || 8;
            timerEnabled = data.timerEnabled || false;

            recalculateGridSize(remoteBoardSize);
            resizeCanvases();
            resetState();

            if (onlineRole === 'host') {
                // Host generates grid and pushes it
                genGrid();
                const gridData = grid.map(row => [...row]);
                await onlineGameRef.child('grid').set(gridData);
                await onlineGameRef.update({ status: 'playing' });
            } else {
                // Guest reads grid from Firebase
                const gridSnap = await onlineGameRef.child('grid').once('value');
                grid = gridSnap.val().map(row => [...row]);
            }

            buildValidWordSet();
            renderHistory();
            updateUI();
            render();
            updateCanvasGlow();
            startTurnTimer();

            // Show online indicator
            const indicator = document.getElementById('online-indicator');
            indicator.style.display = '';
            const roleText = document.getElementById('online-role-text');
            if (onlineRole === 'host') {
                roleText.textContent = 'You are Blue (Host)';
                roleText.style.color = '#60a5fa';
            } else {
                roleText.textContent = 'You are Red (Guest)';
                roleText.style.color = '#f87171';
            }

            // Set up move listener and presence
            setupMoveListener();
            setupPresence();
        }

        function setupMoveListener() {
            const mcRef = onlineGameRef.child('moveCount');
            const mcListener = mcRef.on('value', async (snap) => {
                const newCount = snap.val();
                if (newCount === null || newCount <= onlineMoveCount) return;
                onlineMoveCount = newCount;

                // Read the last move
                const moveSnap = await onlineGameRef.child('lastMove').once('value');
                const move = moveSnap.val();
                if (!move) return;

                const myColor = onlineRole === 'host' ? 'blue' : 'red';
                // Skip if this is my own move
                if (move.player === myColor) return;

                processOpponentMove(move);
            });
            onlineListeners.push({ ref: mcRef, event: 'value', callback: mcListener });
        }

        function processOpponentMove(move) {
            if (move.type === 'pass') {
                addHistory(move.player, null, 0, 0);
                msg('Opponent passed.');
                // Sync grid if provided
                if (move.grid) {
                    grid = move.grid.map(row => [...row]);
                }
                advanceTurn();
                return;
            }

            // Word move
            sel = move.cells;
            player = move.player;

            if (selectionArea() < 1) {
                // Collinear
                addHistory(move.player, move.word, move.strength, 0);
                msg('Opponent played "' + move.word + '" (collinear).');
            } else {
                const scoreBefore = countScores();
                applyTerritory(move.strength);
                startFlash(sel, move.player === 'blue' ? TEAM.BLUE : TEAM.RED);

                const cx = sel.reduce((s, p) => s + cellCenter(p.r, p.c).x, 0) / sel.length;
                const cy = sel.reduce((s, p) => s + cellCenter(p.r, p.c).y, 0) / sel.length;
                spawnParticles(cx, cy, move.player === 'blue' ? TEAM.BLUE : TEAM.RED);

                const scoreAfter = countScores();
                const gained = move.player === 'blue'
                    ? scoreAfter.blue - scoreBefore.blue
                    : scoreAfter.red - scoreBefore.red;

                if (gained > 0) {
                    spawnFloatingText('+' + formatScorePercent(gained), cx, cy, move.player);
                }

                addHistory(move.player, move.word, move.strength, gained);
                msg('Opponent played "' + move.word + '"!');
                playSound('accept');
            }

            // Overwrite grid with synced version
            if (move.grid) {
                grid = move.grid.map(row => [...row]);
            }

            sel = [];
            advanceTurn();
        }

        async function broadcastMove(word, cells, strength, type) {
            if (!onlineMode || !onlineGameRef) return;
            const myColor = onlineRole === 'host' ? 'blue' : 'red';
            const gridData = grid.map(row => [...row]);

            const newMoveCount = onlineMoveCount + 1;
            onlineMoveCount = newMoveCount; // increment BEFORE write to prevent listener double-increment

            const moveData = {
                player: myColor,
                type: type,
                word: word || '',
                cells: cells || [],
                strength: strength || 0,
                grid: gridData,
                moveNum: newMoveCount
            };

            try {
                await onlineGameRef.update({
                    lastMove: moveData,
                    moveCount: newMoveCount
                });
            } catch (e) {
                console.error('Failed to broadcast move:', e);
                msg('Failed to sync move. Connection issue.');
            }
        }

        function setupPresence() {
            const myField = onlineRole === 'host' ? 'host' : 'guest';
            const opponentField = onlineRole === 'host' ? 'guest' : 'host';

            // Watch opponent's presence
            const oppRef = onlineGameRef.child(opponentField);
            const oppListener = oppRef.on('value', (snap) => {
                const val = snap.val();
                const dot = document.getElementById('online-conn-dot');
                const text = document.getElementById('online-conn-text');
                if (val === 'disconnected') {
                    dot.className = 'conn-dot disconnected';
                    text.textContent = 'Opponent disconnected';
                    handleOpponentDisconnect();
                } else if (val === 'connected') {
                    dot.className = 'conn-dot connected';
                    text.textContent = 'Connected';
                }
            });
            onlineListeners.push({ ref: oppRef, event: 'value', callback: oppListener });
        }

        function handleOpponentDisconnect() {
            if (gameOver) return;
            msg('Opponent disconnected!');
            gameOver = true;
            stopTurnTimer();

            const overlay = document.getElementById('game-over');
            const title = document.getElementById('winner-title');
            const scoresEl = document.getElementById('final-scores');
            const subtitle = document.getElementById('winner-subtitle');

            title.textContent = 'Opponent Disconnected';
            title.style.color = '#f59e0b';
            const scores = countScores();
            scoresEl.innerHTML =
                '<span style="color:#60a5fa">Blue: ' + formatScorePercent(scores.blue) + '</span>' +
                '  \u2014  ' +
                '<span style="color:#f87171">Red: ' + formatScorePercent(scores.red) + '</span>';
            subtitle.textContent = 'The game has ended.';

            updateCanvasGlow();
            overlay.classList.add('visible');

            // Update Firebase status
            if (onlineGameRef) {
                onlineGameRef.child('status').set('finished').catch(() => {});
            }
        }

        function cleanupOnlineGame() {
            // Remove all Firebase listeners
            for (const l of onlineListeners) {
                l.ref.off(l.event, l.callback);
            }
            onlineListeners = [];

            // Cancel onDisconnect handlers
            if (onlineGameRef) {
                if (onlineRole === 'host') {
                    onlineGameRef.child('host').onDisconnect().cancel().catch(() => {});
                } else if (onlineRole === 'guest') {
                    onlineGameRef.child('guest').onDisconnect().cancel().catch(() => {});
                }
            }

            // Reset online state
            onlineMode = false;
            onlineRole = null;
            onlineGameRef = null;
            onlineGameCode = '';
            onlineMoveCount = 0;
            onlineGameStarted = false;

            // Hide indicator
            document.getElementById('online-indicator').style.display = 'none';
        }

        async function cancelLobby() {
            // Remove game from Firebase if host
            if (onlineGameRef && onlineRole === 'host') {
                try {
                    onlineGameRef.child('host').onDisconnect().cancel();
                    await onlineGameRef.remove();
                } catch (e) { /* ignore */ }
            }
            if (onlineGameRef && onlineRole === 'guest') {
                try {
                    onlineGameRef.child('guest').onDisconnect().cancel();
                    await onlineGameRef.child('guest').set(null);
                } catch (e) { /* ignore */ }
            }
            cleanupOnlineGame();
            document.getElementById('lobby-screen').classList.add('hidden');
            document.getElementById('menu-screen').classList.remove('hidden');
        }

        function copyGameCode() {
            navigator.clipboard.writeText(onlineGameCode).then(() => {
                msg('Code copied!');
            }).catch(() => {
                msg('Copy failed. Code: ' + onlineGameCode);
            });
        }

        /* ===== Options Menu ===== */
        function openOptions() {
            document.getElementById('options-screen').classList.remove('hidden');
        }

        function closeOptions() {
            document.getElementById('options-screen').classList.add('hidden');
        }

        function setDifficulty(level) {
            aiDifficulty = level;
            document.getElementById('opt-easy').classList.toggle('opt-active', level === 'easy');
            document.getElementById('opt-medium').classList.toggle('opt-active', level === 'medium');
            document.getElementById('opt-expert').classList.toggle('opt-active', level === 'expert');
            const hints = {
                easy: 'AI picks weaker words and sometimes reduces strength.',
                medium: 'Default balanced AI.',
                expert: 'AI picks optimal words and sometimes boosts strength.'
            };
            document.getElementById('difficulty-hint').textContent = hints[level];
        }

        function setTimerOption(seconds) {
            timerEnabled = seconds > 0;
            timerDuration = seconds;
            document.getElementById('opt-timer-off').classList.toggle('opt-active', seconds === 0);
            document.getElementById('opt-timer-30').classList.toggle('opt-active', seconds === 30);
            document.getElementById('opt-timer-60').classList.toggle('opt-active', seconds === 60);
        }

        function setTurnsOption() {
            const input = document.getElementById('opt-turns');
            const hint = document.getElementById('turns-hint');
            const val = parseInt(input.value, 10);

            if (isNaN(val) || val < 1) {
                hint.textContent = '';
                hint.className = 'options-hint';
                input.classList.remove('input-error');
                return;
            }

            if (val > 20) {
                hint.textContent = 'Too Many Turns (Select 1-20)';
                hint.className = 'options-hint turns-error';
                input.classList.add('input-error');
                return;
            }

            input.classList.remove('input-error');
            hint.textContent = '';
            hint.className = 'options-hint';
            TURNS_EACH = val;
        }

        function setBoardSize(size) {
            boardSize = size;
            [9, 10, 11, 12, 13].forEach(s => {
                document.getElementById('opt-size-' + s).classList.toggle('opt-active', s === size);
            });
            const labels = { 9: 'Smallest — tighter fights.', 10: 'Small board.', 11: 'Default board size.', 12: 'Large board — more room to maneuver.', 13: 'Largest — wide open battles.' };
            document.getElementById('size-hint').textContent = labels[size];
        }

        /* ===== Turn Timer ===== */
        function startTurnTimer() {
            stopTurnTimer();
            if (!timerEnabled) {
                document.getElementById('turn-timer').style.display = 'none';
                return;
            }
            turnTimerRemaining = timerDuration;
            const timerEl = document.getElementById('turn-timer');
            timerEl.style.display = '';
            timerEl.textContent = turnTimerRemaining + 's';
            timerEl.classList.remove('timer-urgent');

            turnTimerInterval = setInterval(() => {
                if (aiThinking || submitting || gameOver) return; // pause during AI/submission
                if (onlineMode && !isMyTurn()) return; // only tick on my turn
                turnTimerRemaining--;
                updateTimerDisplay();

                if (turnTimerRemaining <= 0) {
                    stopTurnTimer();
                    msg("Time's up!");
                    sel = [];
                    hideAcceptBtn();
                    addHistory(player, null, 0, 0);
                    if (onlineMode) broadcastMove(null, null, 0, 'pass');
                    advanceTurn();
                }
            }, 1000);
        }

        function stopTurnTimer() {
            if (turnTimerInterval) {
                clearInterval(turnTimerInterval);
                turnTimerInterval = null;
            }
            document.getElementById('turn-timer').style.display = 'none';
        }

        function updateTimerDisplay() {
            const timerEl = document.getElementById('turn-timer');
            timerEl.textContent = turnTimerRemaining + 's';
            if (turnTimerRemaining <= 5) {
                timerEl.classList.add('timer-urgent');
            } else {
                timerEl.classList.remove('timer-urgent');
            }
        }

        /* ===== Init ===== */
        function initCanvas() {
            cvs = document.getElementById('gameCanvas');
            ctx = cvs.getContext('2d');

            tCvs = document.createElement('canvas');
            tCtx = tCvs.getContext('2d');

            flashCvs = document.createElement('canvas');
            flashCtx = flashCvs.getContext('2d');

            resizeCanvases();

            cvs.addEventListener('click', onClick);
            cvs.addEventListener('mousemove', onMouseMove);
            cvs.addEventListener('mouseleave', () => { hoverCell = null; render(); });
        }

        function resizeCanvases() {
            cvs.width = CW;
            cvs.height = CH;
            tCvs.width = GRID_PX;
            tCvs.height = GRID_PX;
            flashCvs.width = GRID_PX;
            flashCvs.height = GRID_PX;
            tOwner = new Uint8Array(GRID_PX * GRID_PX);
            tStrength = new Uint8Array(GRID_PX * GRID_PX);
        }

        function startGame(mode) {
            // Validate turns input before starting
            const turnsInput = document.getElementById('opt-turns');
            const turnsVal = parseInt(turnsInput.value, 10);
            if (isNaN(turnsVal) || turnsVal < 1 || turnsVal > 20) {
                TURNS_EACH = 8; // fallback to default
            } else {
                TURNS_EACH = turnsVal;
            }

            gameMode = mode;

            // Apply board size (tutorial always uses 11x11)
            if (mode === 'tutorial') {
                recalculateGridSize(11);
            } else {
                recalculateGridSize(boardSize);
            }
            resizeCanvases();
            resetState();

            if (mode === 'tutorial') {
                // Use fixed tutorial board
                grid = TUTORIAL_GRID.map(row => [...row]);
                tutorialActive = true;
                tutorialStep = 0;
                tutorialTargetIndex = 0;
            } else {
                genGrid();
                tutorialActive = false;
            }

            buildValidWordSet();
            if (mode === 'pvc') {
                buildAIWordSets();
            }

            // Hide menu
            document.getElementById('menu-screen').classList.add('hidden');

            // Show tutorial overlay if needed
            if (mode === 'tutorial') {
                showTutorialStep();
            }

            renderHistory();
            updateUI();
            render();
            updateCanvasGlow();

            // Start turn timer if enabled
            startTurnTimer();

            // In PvC mode, computer (Blue) goes first
            if (mode === 'pvc') {
                setTimeout(() => aiTakeTurn(), 600);
            }
        }

        function resetState() {
            stopTurnTimer();
            player = 'blue';
            sel = [];
            turnsLeft = { blue: TURNS_EACH, red: TURNS_EACH };
            gameOver = false;
            submitting = false;
            networkError = false;
            aiThinking = false;
            hoverCell = null;
            flashing = false;
            particles = [];
            floatingTexts = [];
            displayedScoreBlue = 0;
            displayedScoreRed = 0;
            history = [];
            tutorialActive = false;
            tutorialStep = 0;
            tutorialTargetIndex = 0;
            tOwner = new Uint8Array(GRID_PX * GRID_PX);
            tStrength = new Uint8Array(GRID_PX * GRID_PX);
            tCtx.clearRect(0, 0, GRID_PX, GRID_PX);
            flashCtx.clearRect(0, 0, GRID_PX, GRID_PX);
            hideAcceptBtn();
            document.getElementById('tutorial-overlay').classList.remove('visible');
            const initDisplayBlue = (questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'doubleturn')
                ? Math.ceil(turnsLeft.blue / 2) : turnsLeft.blue;
            document.getElementById('turns-left').innerHTML =
                '<span class="turns-blue">Blue: ' + initDisplayBlue + '</span> | <span class="turns-red">Red: ' + turnsLeft.red + '</span>';
            // Reset quest-specific state
            questTurnCount = 0;
            questFrozenCells = [];
            questWalrusSpellsUsed = 0;
            questWalrusSpellOrder = [];
            questWalrusDoubleNext = false;
            questHippoFirstTurn = false;
            questPlayerShortRange = false;
            questSnakeMoves = [];
            questSnakeRevealing = false;
        }

        function newGame() {
            if (onlineMode) cleanupOnlineGame();
            // Reset quest state
            if (questMode) {
                MAX_RANGE = 4;
                questMode = false;
                document.getElementById('quest-indicator').style.display = 'none';
            }
            resetState();
            document.getElementById('game-over').classList.remove('visible');
            // Return to menu
            document.getElementById('menu-screen').classList.remove('hidden');
            genGrid();
            renderHistory();
            updateUI();
            render();
        }

        /* ===== Grid generation (weighted) ===== */
        function genGrid() {
            grid = [];
            for (let r = 0; r < GRID; r++) {
                grid[r] = [];
                for (let c = 0; c < GRID; c++) {
                    let letter;
                    let attempts = 0;
                    do {
                        letter = LETTER_BAG[Math.floor(Math.random() * LETTER_BAG.length)];
                        attempts++;
                    } while (attempts < 20 && hasAdjacentDuplicate(r, c, letter));
                    grid[r][c] = letter;
                }
            }
        }

        function hasAdjacentDuplicate(r, c, letter) {
            const neighbors = [[-1,-1],[-1,0],[-1,1],[0,-1]];
            for (const [dr, dc] of neighbors) {
                const nr = r + dr, nc = c + dc;
                if (nr >= 0 && nr < GRID && nc >= 0 && nc < GRID && grid[nr][nc] === letter) return true;
            }
            return false;
        }

        /* ===== Coordinate helpers ===== */
        function cellCenter(r, c) {
            return { x: PAD + c * CELL + CELL / 2, y: PAD + r * CELL + CELL / 2 };
        }

        function canvasToCell(cx, cy) {
            const c = Math.floor((cx - PAD) / CELL);
            const r = Math.floor((cy - PAD) / CELL);
            if (r >= 0 && r < GRID && c >= 0 && c < GRID) return { r, c };
            return null;
        }

        function isPlayerHalf(r, c) {
            if (!questMode || QUEST_ENEMIES[questEnemyIndex]?.power !== 'splitboard') return true;
            return c < Math.floor(GRID / 2);
        }

        function isAIHalf(r, c) {
            if (!questMode || QUEST_ENEMIES[questEnemyIndex]?.power !== 'splitboard') return true;
            return c >= Math.floor(GRID / 2);
        }

        function inRange(r, c) {
            // Splitboard: player can only use their half
            if (questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'splitboard') {
                if (!isPlayerHalf(r, c)) return false;
            }
            if (sel.length === 0) return true;
            const last = sel[sel.length - 1];
            const range = questPlayerShortRange ? 2 : MAX_RANGE;
            return (Math.abs(r - last.r) + Math.abs(c - last.c)) <= range;
        }

        function selectionArea() {
            const pts = sel.map(s => cellCenter(s.r, s.c));
            let area = 0;
            for (let i = 0; i < pts.length; i++) {
                const j = (i + 1) % pts.length;
                area += pts[i].x * pts[j].y - pts[j].x * pts[i].y;
            }
            return Math.abs(area) / 2;
        }

        /* ===== Canvas glow ===== */
        function updateCanvasGlow() {
            if (!cvs) return;
            if (gameOver) {
                cvs.style.boxShadow = '0 4px 24px rgba(0, 0, 0, 0.5)';
                return;
            }
            if (player === 'blue') {
                cvs.style.boxShadow = '0 4px 24px rgba(0, 0, 0, 0.5), 0 0 30px rgba(59, 130, 246, 0.2)';
            } else {
                cvs.style.boxShadow = '0 4px 24px rgba(0, 0, 0, 0.5), 0 0 30px rgba(239, 68, 68, 0.2)';
            }
        }

        /* ===== Hover ===== */
        function onMouseMove(e) {
            const rect = cvs.getBoundingClientRect();
            const sx = cvs.width / rect.width;
            const sy = cvs.height / rect.height;
            const cx = (e.clientX - rect.left) * sx;
            const cy = (e.clientY - rect.top) * sy;
            const cell = canvasToCell(cx, cy);
            const prev = hoverCell;

            hoverCell = cell;

            // Cursor
            if (gameOver || submitting || aiThinking || !cell || (onlineMode && !isMyTurn())) {
                cvs.style.cursor = 'default';
            } else if (grid[cell.r][cell.c] === '') {
                cvs.style.cursor = 'default';
            } else if (questMode && questFrozenCells.some(f => f.r === cell.r && f.c === cell.c)) {
                cvs.style.cursor = 'not-allowed';
            } else if (questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'splitboard' && !isPlayerHalf(cell.r, cell.c)) {
                cvs.style.cursor = 'not-allowed';
            } else if (sel.some(s => s.r === cell.r && s.c === cell.c)) {
                cvs.style.cursor = 'default';
            } else if (!inRange(cell.r, cell.c)) {
                cvs.style.cursor = 'not-allowed';
            } else {
                cvs.style.cursor = 'pointer';
            }

            if (!cellsEq(prev, cell)) render();
        }

        function cellsEq(a, b) {
            if (!a && !b) return true;
            if (!a || !b) return false;
            return a.r === b.r && a.c === b.c;
        }

        /* ===== Click handler ===== */
        function onClick(e) {
            if (gameOver || submitting || aiThinking) return;
            if (onlineMode && !isMyTurn()) return;

            const rect = cvs.getBoundingClientRect();
            const sx = cvs.width / rect.width;
            const sy = cvs.height / rect.height;
            const cx = (e.clientX - rect.left) * sx;
            const cy = (e.clientY - rect.top) * sy;
            const cell = canvasToCell(cx, cy);
            if (!cell) return;

            // Tutorial: only allow clicking highlighted target cells
            if (tutorialActive) {
                const step = TUTORIAL_STEPS[tutorialStep];
                if (step.action !== 'click') return;

                // Check if this cell is the current target
                let targets;
                if (step.target) {
                    targets = [step.target];
                } else if (step.targets) {
                    targets = step.targets;
                } else {
                    return;
                }

                const currentTarget = targets[tutorialTargetIndex];
                if (!currentTarget) return;

                if (cell.r !== currentTarget.r || cell.c !== currentTarget.c) {
                    msg('Click the highlighted cell!');
                    return;
                }

                // Valid tutorial click
                sel.push(cell);
                playSound('select');
                tutorialTargetIndex++;

                // Check if all targets for this step are done
                if (tutorialTargetIndex >= targets.length) {
                    tutorialTargetIndex = 0;
                    tutorialStep++;
                    showTutorialStep();
                }

                updateUI();
                render();
                return;
            }

            if (grid[cell.r][cell.c] === '') return;
            if (!inRange(cell.r, cell.c)) return;

            // Quest: frozen cells cannot be selected
            if (questMode && questFrozenCells.some(f => f.r === cell.r && f.c === cell.c)) {
                msg('That cell is frozen!');
                return;
            }

            // Quest: splitboard - player can only use their half
            if (questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'splitboard' && !isPlayerHalf(cell.r, cell.c)) {
                msg("That's Panda's side of the board!");
                return;
            }

            if (sel.some(s => s.r === cell.r && s.c === cell.c)) {
                msg('Already selected!');
                return;
            }

            // Flamingo: block selecting more than 3 letters
            if (questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'shortwords' && sel.length >= 3) {
                msg('Maximum 3 letters against Flamingo!');
                return;
            }

            hideAcceptBtn();
            sel.push(cell);
            playSound('select');
            updateUI();
            render();
        }

        /* ===== Button actions ===== */
        function undoSelection() {
            if (gameOver || submitting || aiThinking) return;
            if (tutorialActive) return;
            if (onlineMode && !isMyTurn()) return;
            if (sel.length) {
                hideAcceptBtn();
                sel.pop();
                updateUI();
                render();
            }
        }

        function clearSelections() {
            if (gameOver || submitting || aiThinking) return;
            if (tutorialActive) return;
            if (onlineMode && !isMyTurn()) return;
            hideAcceptBtn();
            sel = [];
            updateUI();
            render();
        }

        function passTurn() {
            if (gameOver || submitting || aiThinking) return;
            if (tutorialActive) return;
            if (onlineMode && !isMyTurn()) return;
            showPassConfirm();
        }

        function showPassConfirm() {
            document.getElementById('pass-confirm').classList.add('visible');
        }

        function confirmPass() {
            document.getElementById('pass-confirm').classList.remove('visible');
            hideAcceptBtn();
            addHistory(player, null, 0, 0);
            if (onlineMode) broadcastMove(null, null, 0, 'pass');
            advanceTurn();
            msg('Turn passed.');
        }

        function cancelPass() {
            document.getElementById('pass-confirm').classList.remove('visible');
        }

        async function validateWord(word) {
            const upper = word.toUpperCase();
            // Tier 1: Local word set
            if (VALID_WORD_SET && VALID_WORD_SET.has(upper)) {
                return { valid: true, source: 'local' };
            }
            // Tier 2: Primary dictionary API
            try {
                const resp = await fetch(API_URL + word.toLowerCase());
                if (resp.ok) return { valid: true, source: 'primary' };
            } catch (e) {
                // Network error — fall through to fallback
            }
            // Tier 3: Datamuse fallback API
            try {
                const resp = await fetch(API_URL_FALLBACK + word.toLowerCase() + '&max=1');
                if (resp.ok) {
                    const data = await resp.json();
                    if (data.length > 0 && data[0].word === word.toLowerCase()) {
                        return { valid: true, source: 'fallback' };
                    }
                }
            } catch (e) {
                // Both APIs failed — treat as network error
                return { valid: false, source: 'error' };
            }
            return { valid: false, source: 'rejected' };
        }

        async function submitWord() {
            if (gameOver || submitting || aiThinking) return;
            if (onlineMode && !isMyTurn()) return;
            if (sel.length < 3) { msg('Minimum 3 letters!'); return; }

            const word = sel.map(s => grid[s.r][s.c]).join('');
            const strength = Math.min(sel.length - 2, 5);

            // Tutorial: skip API validation
            if (tutorialActive) {
                finalizeWord(word, strength);
                // Advance tutorial
                const step = TUTORIAL_STEPS[tutorialStep];
                if (step && step.action === 'submit') {
                    tutorialStep++;
                    showTutorialStep();
                }
                return;
            }

            // Word validation (local → primary API → fallback API)
            submitting = true;
            setButtonsDisabled(true);
            document.getElementById('btn-submit').textContent = 'Checking...';
            msg('Checking "' + word + '"...');

            const result = await validateWord(word);

            submitting = false;
            setButtonsDisabled(false);
            document.getElementById('btn-submit').textContent = 'Submit Word';

            if (result.source === 'error') {
                msg('Network error \u2014 retry or Accept Anyway.');
                showAcceptBtn();
                playSound('reject');
                return;
            }

            if (!result.valid) {
                msg('"' + word + '" is not a valid word!');
                playSound('reject');
                return;
            }

            finalizeWord(word, strength);
        }

        function acceptAnyway() {
            if (gameOver || sel.length < 3 || aiThinking) return;
            if (tutorialActive) return;
            if (onlineMode && !isMyTurn()) return;
            hideAcceptBtn();
            const word = sel.map(s => grid[s.r][s.c]).join('');
            const strength = Math.min(sel.length - 2, 5);
            finalizeWord(word, strength);
        }

        function removeUsedLetters() {
            for (const s of sel) {
                grid[s.r][s.c] = '';
            }
        }

        function finalizeWord(word, strength) {
            // Collinear check
            if (selectionArea() < 1) {
                msg('"' + word + '" accepted \u2014 no territory (collinear).');
                addHistory(player, word, strength, 0);
                playSound('accept');
                removeUsedLetters();
                if (onlineMode && isMyTurn()) broadcastMove(word, sel.map(s => ({r:s.r, c:s.c})), strength, 'word');
                advanceTurn();
                return;
            }

            // Sneaky Snake: record move for end-of-game reveal
            if (questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'stealth') {
                questSnakeMoves.push({ path: sel.map(s => ({r: s.r, c: s.c})), player, strength });
            }

            const scoreBefore = countScores();
            applyTerritory(strength);

            const isSnakeStealth = questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'stealth' && !questSnakeRevealing;

            if (!isSnakeStealth) {
                startFlash(sel, player === 'blue' ? TEAM.BLUE : TEAM.RED);
            }

            // Spawn particles at polygon centroid
            const cx = sel.reduce((s, p) => s + cellCenter(p.r, p.c).x, 0) / sel.length;
            const cy = sel.reduce((s, p) => s + cellCenter(p.r, p.c).y, 0) / sel.length;
            if (!isSnakeStealth) {
                spawnParticles(cx, cy, player === 'blue' ? TEAM.BLUE : TEAM.RED);
            }

            const scoreAfter = countScores();
            const gained = player === 'blue'
                ? scoreAfter.blue - scoreBefore.blue
                : scoreAfter.red - scoreBefore.red;

            // Spawn floating score text
            if (gained > 0 && !isSnakeStealth) {
                spawnFloatingText('+' + formatScorePercent(gained), cx, cy, player);
            }

            addHistory(player, word, strength, isSnakeStealth ? -1 : gained);
            msg(isSnakeStealth ? ('"' + word + '" accepted!') : ('"' + word + '" captured! Strength ' + strength));
            playSound('accept');
            removeUsedLetters();
            if (onlineMode && isMyTurn()) broadcastMove(word, sel.map(s => ({r:s.r, c:s.c})), strength, 'word');
            advanceTurn();
        }

        function advanceTurn() {
            // Clear short range after player (red) finishes their turn
            if (player === 'red' && questPlayerShortRange) {
                questPlayerShortRange = false;
            }

            turnsLeft[player]--;
            sel = [];
            player = player === 'blue' ? 'red' : 'blue';

            // Quest: increment turn count and manage frozen cells
            if (questMode) {
                questTurnCount++;
                for (let i = questFrozenCells.length - 1; i >= 0; i--) {
                    questFrozenCells[i].turnsLeft--;
                    if (questFrozenCells[i].turnsLeft <= 0) {
                        questFrozenCells.splice(i, 1);
                    }
                }
            }

            // Turn pulse animation
            const ti = document.getElementById('turn-indicator');
            ti.classList.remove('pulse');
            void ti.offsetWidth; // reflow to restart animation
            ti.classList.add('pulse');

            updateUI();
            render();
            updateCanvasGlow();

            if (turnsLeft.blue <= 0 && turnsLeft.red <= 0) {
                endGame();
                return;
            }

            // Restart turn timer
            startTurnTimer();

            // PvC: trigger AI turn when it's Blue's turn
            if (gameMode === 'pvc' && !onlineMode && player === 'blue' && !gameOver) {
                setTimeout(() => aiTakeTurn(), 600);
            }
        }

        function showAcceptBtn() {
            document.getElementById('btn-accept').style.display = '';
        }

        function hideAcceptBtn() {
            document.getElementById('btn-accept').style.display = 'none';
            networkError = false;
        }

        function setButtonsDisabled(d) {
            document.getElementById('btn-submit').disabled = d;
            document.getElementById('btn-undo').disabled = d;
            document.getElementById('btn-clear').disabled = d;
            document.getElementById('btn-pass').disabled = d;
        }

        /* ===== Territory logic ===== */
        function applyTerritory(strength) {
            const tmp = document.createElement('canvas');
            tmp.width = GRID_PX;
            tmp.height = GRID_PX;
            const tc = tmp.getContext('2d', { willReadFrequently: true });

            tc.fillStyle = '#fff';
            tc.beginPath();
            for (let i = 0; i < sel.length; i++) {
                const p = cellCenter(sel[i].r, sel[i].c);
                if (i === 0) tc.moveTo(p.x - PAD, p.y - PAD);
                else tc.lineTo(p.x - PAD, p.y - PAD);
            }
            tc.closePath();
            tc.fill();

            const px = tc.getImageData(0, 0, GRID_PX, GRID_PX).data;
            const atkTeam = player === 'blue' ? TEAM.BLUE : TEAM.RED;

            for (let i = 0; i < GRID_PX * GRID_PX; i++) {
                if (px[i * 4] > 128) {
                    const co = tOwner[i];
                    const cs = tStrength[i];

                    if (co === TEAM.NONE || co === TEAM.NEUTRAL) {
                        tOwner[i] = atkTeam;
                        tStrength[i] = strength;
                    } else if (co === atkTeam) {
                        tStrength[i] = Math.min(cs + strength, 5);
                    } else {
                        if (strength < cs) {
                            tStrength[i] = cs - strength;
                        } else if (strength === cs) {
                            tOwner[i] = TEAM.NEUTRAL;
                            tStrength[i] = 0;
                        } else {
                            tOwner[i] = atkTeam;
                            tStrength[i] = strength - cs;
                        }
                    }
                }
            }

            rebuildTerritoryVisual();
        }

        function rebuildTerritoryVisual() {
            const imgData = tCtx.createImageData(GRID_PX, GRID_PX);
            const d = imgData.data;

            for (let i = 0; i < GRID_PX * GRID_PX; i++) {
                const owner = tOwner[i];
                const str = tStrength[i];
                if (owner === TEAM.NONE) continue;

                const col = TEAM_RGB[owner];
                const idx = i * 4;
                d[idx]     = col.r;
                d[idx + 1] = col.g;
                d[idx + 2] = col.b;
                d[idx + 3] = owner === TEAM.NEUTRAL ? NEUTRAL_ALPHA : (str > 0 ? STR_ALPHA[str] : 0);
            }

            tCtx.putImageData(imgData, 0, 0);
        }

        /* ===== Flash animation ===== */
        function startFlash(polygon, team) {
            flashCtx.clearRect(0, 0, GRID_PX, GRID_PX);
            const col = TEAM_RGB[team];
            flashCtx.fillStyle = 'rgba(' + col.r + ',' + col.g + ',' + col.b + ',0.45)';
            flashCtx.beginPath();
            for (let i = 0; i < polygon.length; i++) {
                const p = cellCenter(polygon[i].r, polygon[i].c);
                if (i === 0) flashCtx.moveTo(p.x - PAD, p.y - PAD);
                else flashCtx.lineTo(p.x - PAD, p.y - PAD);
            }
            flashCtx.closePath();
            flashCtx.fill();

            flashStart = performance.now();
            flashing = true;
            requestAnimationFrame(animateFlash);
        }

        function animateFlash(now) {
            const progress = Math.min((now - flashStart) / FLASH_MS, 1);
            render();

            ctx.globalAlpha = 1 - progress;
            ctx.drawImage(flashCvs, PAD, PAD);
            ctx.globalAlpha = 1;

            if (progress < 1) requestAnimationFrame(animateFlash);
            else flashing = false;
        }

        /* ===== Particle system ===== */
        function spawnParticles(cx, cy, team) {
            const col = TEAM_RGB[team];
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 60 + Math.random() * 120;
                particles.push({
                    x: cx, y: cy,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    decay: 0.8 + Math.random() * 0.8,
                    size: 2 + Math.random() * 3,
                    r: col.r, g: col.g, b: col.b
                });
            }
            if (!particleAnimating) {
                particleAnimating = true;
                lastParticleTime = performance.now();
                requestAnimationFrame(animateParticles);
            }
        }

        let particleAnimating = false;
        let lastParticleTime = 0;

        function animateParticles(now) {
            const dt = Math.min((now - lastParticleTime) / 1000, 0.05);
            lastParticleTime = now;

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vy += 80 * dt; // gravity
                p.life -= p.decay * dt;
                if (p.life <= 0) particles.splice(i, 1);
            }

            render();

            // Draw particles on top
            for (const p of particles) {
                ctx.globalAlpha = Math.max(0, p.life);
                ctx.fillStyle = 'rgb(' + p.r + ',' + p.g + ',' + p.b + ')';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            if (particles.length > 0) {
                requestAnimationFrame(animateParticles);
            } else {
                particleAnimating = false;
            }
        }

        /* ===== Floating score text ===== */
        function spawnFloatingText(text, cx, cy, plr) {
            floatingTexts.push({
                text,
                x: cx, y: cy,
                life: 1.0,
                color: plr === 'blue' ? '#60a5fa' : '#f87171'
            });
            if (!floatAnimating) {
                floatAnimating = true;
                lastFloatTime = performance.now();
                requestAnimationFrame(animateFloatingTexts);
            }
        }

        let floatAnimating = false;
        let lastFloatTime = 0;

        function animateFloatingTexts(now) {
            const dt = Math.min((now - lastFloatTime) / 1000, 0.05);
            lastFloatTime = now;

            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const ft = floatingTexts[i];
                ft.y -= 50 * dt;
                ft.life -= 0.7 * dt;
                if (ft.life <= 0) floatingTexts.splice(i, 1);
            }

            render();

            // Draw floating texts
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            for (const ft of floatingTexts) {
                ctx.globalAlpha = Math.max(0, ft.life);
                ctx.font = 'bold 18px sans-serif';
                ctx.fillStyle = ft.color;
                ctx.fillText(ft.text, ft.x, ft.y);
            }
            ctx.globalAlpha = 1;

            if (floatingTexts.length > 0) {
                requestAnimationFrame(animateFloatingTexts);
            } else {
                floatAnimating = false;
            }
        }

        /* ===== Animated score counters ===== */
        function startScoreAnimation() {
            const scores = countScores();
            const blueChanged = scores.blue !== scoreAnimTargetBlue;
            const redChanged = scores.red !== scoreAnimTargetRed;

            if (blueChanged || redChanged) {
                scoreAnimStartTime = performance.now();
                scoreAnimStartBlue = displayedScoreBlue;
                scoreAnimStartRed = displayedScoreRed;
                scoreAnimTargetBlue = scores.blue;
                scoreAnimTargetRed = scores.red;

                // Add enlarge class to the player whose score changed
                if (blueChanged) document.getElementById('blue-score').classList.add('score-animating');
                if (redChanged) document.getElementById('red-score').classList.add('score-animating');
            }

            if (animatingScores) return;
            animatingScores = true;
            requestAnimationFrame(animateScoreCounters);
        }

        function animateScoreCounters() {
            const elapsed = performance.now() - scoreAnimStartTime;
            const duration = 2000;
            const t = Math.min(elapsed / duration, 1);
            const eased = 1 - Math.pow(1 - t, 3); // cubic ease-out

            displayedScoreBlue = Math.round(scoreAnimStartBlue + (scoreAnimTargetBlue - scoreAnimStartBlue) * eased);
            displayedScoreRed = Math.round(scoreAnimStartRed + (scoreAnimTargetRed - scoreAnimStartRed) * eased);

            const blueLabel = questMode ? QUEST_ENEMIES[questEnemyIndex].name.split(' ').pop() + ': ' : (gameMode === 'pvc' ? 'CPU: ' : 'Blue: ');
            const redLabel = (questMode || gameMode === 'pvc') ? 'You: ' : 'Red: ';

            // Sneaky Snake: hide scores during stealth
            const snakeStealth = questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'stealth' && !questSnakeRevealing && !gameOver;
            document.getElementById('blue-score-value').textContent = blueLabel + (snakeStealth ? '???' : formatScorePercent(displayedScoreBlue));
            document.getElementById('red-score-value').textContent = redLabel + (snakeStealth ? '???' : formatScorePercent(displayedScoreRed));

            if (t < 1) {
                requestAnimationFrame(animateScoreCounters);
            } else {
                animatingScores = false;
                // Remove enlarge class after a short delay
                setTimeout(() => {
                    document.getElementById('blue-score').classList.remove('score-animating');
                    document.getElementById('red-score').classList.remove('score-animating');
                }, 300);
            }
        }

        /* ===== Scoring ===== */
        function countScores() {
            let blue = 0, red = 0;
            for (let i = 0; i < GRID_PX * GRID_PX; i++) {
                if (tOwner[i] === TEAM.BLUE) blue++;
                else if (tOwner[i] === TEAM.RED) red++;
            }
            return { blue, red };
        }

        /* ===== History ===== */
        function addHistory(plr, word, strength, gained) {
            history.push({ player: plr, word, strength, gained });
            renderHistory();
        }

        function renderHistory() {
            const list = document.getElementById('history-list');

            if (history.length === 0) {
                list.innerHTML = '<div class="history-empty">No turns yet</div>';
                return;
            }

            let html = '';
            for (let i = 0; i < history.length; i++) {
                const h = history[i];
                const dotClass = h.player === 'blue' ? 'blue' : 'red';
                const label = (questMode && h.player === 'blue') ? QUEST_ENEMIES[questEnemyIndex].name.split(' ').pop() : ((gameMode === 'pvc' && h.player === 'blue') ? 'CPU' : '');
                html += '<div class="history-entry">';
                html += '<span class="history-dot ' + dotClass + '"></span>';

                if (!h.word) {
                    html += '<span class="history-pass">Passed</span>';
                } else if (h.gained === -1) {
                    // Sneaky Snake stealth: hide territory gain
                    html += '<span class="history-word">' + h.word + '</span>';
                    html += '<span class="history-info" style="color:#10b981;">???</span>';
                } else if (h.gained === 0) {
                    html += '<span class="history-word">' + h.word + '</span>';
                    html += '<span class="history-info history-collinear">0.0%</span>';
                } else {
                    html += '<span class="history-word">' + h.word + '</span>';
                    html += '<span class="history-info">+' + formatScorePercent(h.gained) + '</span>';
                }

                html += '</div>';
            }

            list.innerHTML = html;
            list.scrollTop = list.scrollHeight;
        }

        /* ===== AI System ===== */
        function aiFindWords() {
            const found = [];
            const visited = Array.from({length: GRID}, () => new Array(GRID).fill(false));
            const isSquirrel = questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'range';
            const isPenguin = questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'science';
            const isFlamingo = questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'shortwords';
            const isSplitboard = questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'splitboard';
            const aiRange = isSquirrel ? 7 : MAX_RANGE;
            const aiMaxLen = isFlamingo ? 3 : (isPenguin ? 8 : (isSquirrel ? 4 : 5));
            const aiMinLen = isPenguin ? 6 : 3;
            const aiHalfStart = isSplitboard ? Math.floor(GRID / 2) : 0;

            // Penguin uses science-only word/prefix sets
            if (isPenguin) buildPenguinWordSets();
            const wordSet = isPenguin ? PENGUIN_WORD_SET : AI_WORD_SET;
            const prefixSet = isPenguin ? PENGUIN_PREFIX_SET : AI_PREFIX_SET;

            function dfs(path, word) {
                if (word.length >= aiMinLen && wordSet.has(word)) {
                    found.push({ word, path: path.map(p => ({...p})) });
                }
                if (word.length >= aiMaxLen) return;
                const last = path[path.length - 1];

                for (let r = 0; r < GRID; r++) {
                    for (let c = aiHalfStart; c < GRID; c++) {
                        if (visited[r][c]) continue;
                        if (grid[r][c] === '') continue;
                        // Manhattan distance check (quest: squirrel gets extended range)
                        if ((Math.abs(r - last.r) + Math.abs(c - last.c)) > aiRange) continue;

                        const nextWord = word + grid[r][c];
                        if (!prefixSet.has(nextWord)) continue;

                        visited[r][c] = true;
                        path.push({r, c});
                        dfs(path, nextWord);
                        path.pop();
                        visited[r][c] = false;
                    }
                }
            }

            for (let r = 0; r < GRID; r++) {
                for (let c = aiHalfStart; c < GRID; c++) {
                    if (grid[r][c] === '') continue;
                    const letter = grid[r][c];
                    if (!prefixSet.has(letter)) continue;
                    visited[r][c] = true;
                    dfs([{r, c}], letter);
                    visited[r][c] = false;
                }
            }

            return found;
        }

        function aiCalculateArea(path) {
            if (path.length < 3) return 0;
            const pts = path.map(s => cellCenter(s.r, s.c));
            let area = 0;
            for (let i = 0; i < pts.length; i++) {
                const j = (i + 1) % pts.length;
                area += pts[i].x * pts[j].y - pts[j].x * pts[i].y;
            }
            return Math.abs(area) / 2;
        }

        function aiChooseWord(candidates) {
            const isSquirrel = questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'range';
            const isHippo = questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'doubleturn';
            const isTurtle = questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'superstrength';
            const isPanda = questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'splitboard';

            // Hip Hop Hippo: cap territory at 10% per play
            if (isHippo) {
                const maxArea = TOTAL_PIXELS * 0.10;
                candidates = candidates.filter(c => aiCalculateArea(c.path) <= maxArea);
            }

            // Stretchy Squirrel: cap territory at 20% per play
            if (isSquirrel) {
                const maxArea = TOTAL_PIXELS * 0.20;
                candidates = candidates.filter(c => aiCalculateArea(c.path) <= maxArea);
            }

            // Tenacious Turtle: remove the top 10% largest-area candidates to reduce territory
            if (isTurtle && candidates.length > 1) {
                const sorted = [...candidates].sort((a, b) => aiCalculateArea(b.path) - aiCalculateArea(a.path));
                const cutoff = Math.max(1, Math.floor(candidates.length * 0.1));
                const excluded = new Set(sorted.slice(0, cutoff));
                candidates = candidates.filter(c => !excluded.has(c));
            }

            // Filter to words with area (non-collinear with 3+ letters)
            const minArea = TOTAL_PIXELS * 0.03;
            let withArea = candidates.filter(c => c.path.length >= 3 && aiCalculateArea(c.path) >= minArea);

            // If no words meet the 3% threshold, try any with area
            if (withArea.length === 0) {
                withArea = candidates.filter(c => c.path.length >= 3 && aiCalculateArea(c.path) > 100);
            }
            // If still none, try any valid words
            if (withArea.length === 0) {
                withArea = candidates.filter(c => c.path.length >= 3);
            }
            if (withArea.length === 0) return null;

            // Difficulty-dependent weights
            const diffSettings = {
                easy:   { randomness: 1000, areaMult: 0.3, lengthMult: 0.4, topN: 20 },
                medium: { randomness: 600,  areaMult: 1.0, lengthMult: 1.0, topN: 8 },
                expert: { randomness: 200,  areaMult: 1.5, lengthMult: 1.2, topN: 3 }
            };
            const diff = diffSettings[aiDifficulty] || diffSettings.medium;

            const scored = withArea.map(c => {
                const area = aiCalculateArea(c.path);
                const len = c.path.length;

                // Length preference (expert favors longer words)
                let lengthBonus = 0;
                if (aiDifficulty === 'expert') {
                    if (len >= 5) lengthBonus = 800;
                    else if (len === 4) lengthBonus = 400;
                    else if (len === 3) lengthBonus = 100;
                } else {
                    if (len === 4) lengthBonus = 500;
                    else if (len === 3) lengthBonus = 250;
                    else if (len === 5) lengthBonus = 100;
                }
                lengthBonus *= diff.lengthMult;

                // Distance bonus: easy rewards proximity, medium/expert reward spread
                let totalDist = 0;
                for (let i = 1; i < c.path.length; i++) {
                    totalDist += Math.abs(c.path[i].r - c.path[i-1].r) + Math.abs(c.path[i].c - c.path[i-1].c);
                }
                const avgDist = totalDist / (c.path.length - 1);
                const distBonus = aiDifficulty === 'easy'
                    ? (MAX_RANGE - avgDist) * 200  // proximity: closer = higher score
                    : avgDist * 120;                // spread: farther = higher score

                // Area bonus: reward larger territory polygons
                const areaBonus = Math.min(area * 0.05, 1200) * diff.areaMult;

                // Irregularity bonus: reward shapes that aren't simple rectangles/triangles
                // Measures how much the path zigzags by checking angle changes between steps
                let irregularity = 0;
                if (len >= 3) {
                    for (let i = 1; i < len - 1; i++) {
                        const dr1 = c.path[i].r - c.path[i-1].r;
                        const dc1 = c.path[i].c - c.path[i-1].c;
                        const dr2 = c.path[i+1].r - c.path[i].r;
                        const dc2 = c.path[i+1].c - c.path[i].c;
                        // Cross product magnitude — nonzero means direction change
                        const cross = Math.abs(dr1 * dc2 - dc1 * dr2);
                        // Dot product sign — negative means backtracking (sharper turn)
                        const dot = dr1 * dr2 + dc1 * dc2;
                        irregularity += cross > 0 ? 1 : 0;
                        if (dot < 0) irregularity += 0.5; // extra for sharp turns
                    }
                    irregularity = irregularity / (len - 2); // normalize to 0-1.5 range
                }
                const irregularityBonus = irregularity * 350;

                // Overlap with enemy territory
                let overlapBonus = 0;
                const centroidX = c.path.reduce((s, p) => s + p.c, 0) / c.path.length;
                const centroidY = c.path.reduce((s, p) => s + p.r, 0) / c.path.length;
                const px = Math.floor(centroidY * CELL + CELL/2);
                const py = Math.floor(centroidX * CELL + CELL/2);
                const idx = px * GRID_PX + py;
                if (idx >= 0 && idx < GRID_PX * GRID_PX) {
                    if (tOwner[idx] === TEAM.RED) overlapBonus = 150;
                }

                // Stretchy Squirrel: huge bonus for words with a stretch of 6+ tiles
                let stretchBonus = 0;
                if (isSquirrel) {
                    for (let i = 1; i < c.path.length; i++) {
                        const d = Math.abs(c.path[i].r - c.path[i-1].r) + Math.abs(c.path[i].c - c.path[i-1].c);
                        if (d >= 6) { stretchBonus = 3000; break; }
                    }
                }

                // Petty Panda: bonus for hugging edges and spreading across the half
                let pandaBonus = 0;
                if (isPanda) {
                    const halfStart = Math.floor(GRID / 2); // left edge of AI half
                    const halfEnd = GRID - 1;               // right edge
                    const halfWidth = halfEnd - halfStart;   // columns available
                    const rows = c.path.map(p => p.r);
                    const cols = c.path.map(p => p.c);
                    const minR = Math.min(...rows), maxR = Math.max(...rows);
                    const minC = Math.min(...cols), maxC = Math.max(...cols);

                    // Spread bonus: reward paths covering a large fraction of the AI half
                    const rowSpread = (maxR - minR) / (GRID - 1);    // 0-1
                    const colSpread = (maxC - minC) / halfWidth;     // 0-1
                    pandaBonus += (rowSpread + colSpread) * 1500;

                    // Edge proximity bonus: reward touching or being near edges
                    const topDist = minR;                    // distance to top edge
                    const botDist = (GRID - 1) - maxR;      // distance to bottom edge
                    const leftDist = minC - halfStart;       // distance to divider edge
                    const rightDist = halfEnd - maxC;        // distance to right edge
                    // Bonus for each edge the path gets close to (within 1 cell)
                    if (topDist <= 1) pandaBonus += 600;
                    if (botDist <= 1) pandaBonus += 600;
                    if (leftDist <= 1) pandaBonus += 600;
                    if (rightDist <= 1) pandaBonus += 600;

                    // Unclaimed territory bonus: prefer areas AI hasn't already claimed
                    const cx = Math.floor((minC + maxC) / 2);
                    const cy = Math.floor((minR + maxR) / 2);
                    const px = cy * CELL + CELL / 2;
                    const py = cx * CELL + CELL / 2;
                    const pidx = Math.floor(px) * GRID_PX + Math.floor(py);
                    if (pidx >= 0 && pidx < GRID_PX * GRID_PX && tOwner[pidx] !== TEAM.BLUE) {
                        pandaBonus += 800;
                    }
                }

                const score = lengthBonus + distBonus + areaBonus + irregularityBonus + overlapBonus + stretchBonus + pandaBonus + Math.random() * diff.randomness;
                return { ...c, score };
            });

            scored.sort((a, b) => b.score - a.score);
            const topN = Math.min(diff.topN, scored.length);

            // Stretchy Squirrel: always prefer words with a 6+ tile stretch when available
            if (isSquirrel) {
                const stretchCandidates = scored.filter(c => {
                    for (let i = 1; i < c.path.length; i++) {
                        const d = Math.abs(c.path[i].r - c.path[i-1].r) + Math.abs(c.path[i].c - c.path[i-1].c);
                        if (d >= 6) return true;
                    }
                    return false;
                });
                if (stretchCandidates.length > 0) {
                    const pick = Math.min(3, stretchCandidates.length);
                    return stretchCandidates[Math.floor(Math.random() * pick)];
                }
            }

            return scored[Math.floor(Math.random() * topN)];
        }

        async function aiPlayOneTurn() {
            // Brief delay for natural feel
            await new Promise(r => setTimeout(r, 800 + Math.random() * 700));

            // Find words
            const candidates = aiFindWords();
            const chosen = aiChooseWord(candidates);

            if (!chosen) {
                // Pass turn
                aiThinking = false;
                setButtonsDisabled(false);
                addHistory('blue', null, 0, 0);
                msg('Computer passed.');
                advanceTurn();
                return false; // did not play a word
            }

            // Animate letter selection one at a time
            sel = [];
            for (let i = 0; i < chosen.path.length; i++) {
                sel.push(chosen.path[i]);
                playSound('select');
                updateUI();
                render();
                await new Promise(r => setTimeout(r, 250));
            }

            const word = chosen.word.toUpperCase();
            let strength = Math.min(chosen.path.length - 2, 5);

            // Difficulty-based strength scaling
            if (aiDifficulty === 'easy' && Math.random() < 0.55) {
                strength = Math.max(1, strength - 1);
            } else if (aiDifficulty === 'expert' && Math.random() < 0.5) {
                strength = Math.min(5, strength + 1);
            }

            // Quest: Tenacious Turtle — maximum strength on all plays
            if (questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'superstrength') {
                strength = 5;
            }

            // Quest: Professor Penguin — announce the scientific term
            if (questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'science') {
                msg('Professor played: ' + word + '!');
            }


            // AI words come from curated list — skip API validation
            aiThinking = false;
            setButtonsDisabled(false);
            finalizeWord(word, strength);
            return true; // played a word
        }

        async function aiTakeTurn() {
            if (gameOver || player !== 'blue' || gameMode !== 'pvc') return;
            aiThinking = true;
            msg('Computer is thinking...');
            setButtonsDisabled(true);
            render();

            // Quest: apply pre-AI powers
            if (questMode) {
                await applyQuestPower('beforeAI');
            }

            const isHippoDouble = questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'doubleturn';

            // First turn
            const played = await aiPlayOneTurn();

            // Quest: apply post-AI powers (only if game hasn't ended)
            if (questMode && !gameOver) {
                await applyQuestPower('afterAI');
            }

            // Hip Hop Hippo: play a second turn
            if (isHippoDouble && !gameOver && played) {
                // advanceTurn() already switched player to 'red' — switch back to 'blue'
                player = 'blue';
                aiThinking = true;
                msg('Hippo plays again...');
                setButtonsDisabled(true);
                render();

                await aiPlayOneTurn();

                // Post-AI powers after second turn
                if (questMode && !gameOver) {
                    await applyQuestPower('afterAI');
                }
            }
        }

        /* ===== Tutorial System ===== */
        function showTutorialStep() {
            if (tutorialStep >= TUTORIAL_STEPS.length) {
                // Tutorial complete
                tutorialActive = false;
                document.getElementById('tutorial-overlay').classList.remove('visible');
                newGame();
                return;
            }

            const step = TUTORIAL_STEPS[tutorialStep];
            const overlay = document.getElementById('tutorial-overlay');
            document.getElementById('tutorial-step-title').textContent = step.title;
            document.getElementById('tutorial-step-desc').innerHTML = step.desc;

            const nextBtn = document.getElementById('btn-tutorial-next');
            document.getElementById('btn-tutorial-skip').style.display = '';
            if (step.action === 'next') {
                nextBtn.style.display = '';
                nextBtn.textContent = 'Next';
            } else if (step.action === 'done') {
                nextBtn.style.display = '';
                nextBtn.textContent = 'Return to Menu';
                document.getElementById('btn-tutorial-skip').style.display = 'none';
            } else if (step.action === 'submit') {
                nextBtn.style.display = 'none';
            } else {
                // 'click' - hide next, player must click cells
                nextBtn.style.display = 'none';
            }

            overlay.classList.add('visible');
            tutorialTargetIndex = 0;
            render();
        }

        function tutorialNext() {
            const step = TUTORIAL_STEPS[tutorialStep];
            if (step.action === 'done') {
                tutorialActive = false;
                document.getElementById('tutorial-overlay').classList.remove('visible');
                newGame();
                return;
            }
            tutorialStep++;
            showTutorialStep();
        }

        function tutorialSkip() {
            tutorialActive = false;
            document.getElementById('tutorial-overlay').classList.remove('visible');
            newGame();
        }

        /* ===== Game end ===== */
        function endGame() {
            gameOver = true;
            stopTurnTimer();

            // Sneaky Snake: reveal territories one by one before showing results
            if (questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'stealth' && !questSnakeRevealing && questSnakeMoves.length > 0) {
                questSnakeRevealing = true;
                // Save final state, then clear territory for replay
                const savedOwner = new Uint8Array(tOwner);
                const savedStrength = new Uint8Array(tStrength);
                tOwner.fill(TEAM.NONE);
                tStrength.fill(0);
                rebuildTerritoryVisual();
                render();

                msg('Revealing territories...');

                let moveIdx = 0;
                function revealNext() {
                    if (moveIdx >= questSnakeMoves.length) {
                        // Restore final state (handles overlapping territory correctly)
                        tOwner.set(savedOwner);
                        tStrength.set(savedStrength);
                        rebuildTerritoryVisual();
                        render();
                        startScoreAnimation();
                        // Now show the actual endGame overlay
                        setTimeout(() => endGame(), 800);
                        return;
                    }
                    const move = questSnakeMoves[moveIdx];
                    // Temporarily set sel and player so applyTerritory works
                    sel = move.path;
                    player = move.player;
                    applyTerritory(move.strength);
                    startFlash(sel, move.player === 'blue' ? TEAM.BLUE : TEAM.RED);
                    render();
                    startScoreAnimation();
                    sel = [];
                    moveIdx++;
                    setTimeout(revealNext, 1000);
                }
                revealNext();
                return;
            }

            playSound('gameend');
            const scores = countScores();
            const overlay = document.getElementById('game-over');
            const title = document.getElementById('winner-title');
            const scoresEl = document.getElementById('final-scores');
            const subtitle = document.getElementById('winner-subtitle');

            if (questMode) {
                const enemy = QUEST_ENEMIES[questEnemyIndex];
                scoresEl.innerHTML =
                    '<span style="color:#60a5fa">' + enemy.name + ': ' + formatScorePercent(scores.blue) + '</span>' +
                    '  \u2014  ' +
                    '<span style="color:#f87171">You: ' + formatScorePercent(scores.red) + '</span>';

                if (scores.red > scores.blue) {
                    // Player wins
                    title.textContent = 'Victory!';
                    title.style.color = '#34d399';
                    subtitle.textContent = 'You defeated ' + enemy.name + '!';

                    // Save progress
                    if (!questProgress.includes(questEnemyIndex)) {
                        questProgress.push(questEnemyIndex);
                        localStorage.setItem('questProgress', JSON.stringify(questProgress));
                    }

                    // Check if all 6 defeated
                    if (questProgress.length >= QUEST_ENEMIES.length) {
                        // Delay then show victory screen
                        setTimeout(() => {
                            overlay.classList.remove('visible');
                            showVictoryScreen();
                        }, 2000);
                    }
                } else if (scores.blue > scores.red) {
                    title.textContent = 'Defeat!';
                    title.style.color = '#f87171';
                    subtitle.textContent = enemy.name + ' wins by ' + formatScorePercent(scores.blue - scores.red) + ' territory';
                } else {
                    title.textContent = 'Draw!';
                    title.style.color = '#e2e8f0';
                    subtitle.textContent = 'A tie against ' + enemy.name;
                }

                // Replace button with quest-specific behavior
                const goBtn = document.getElementById('btn-game-over');
                goBtn.textContent = 'Continue Campaign';
                const playerWon = scores.red > scores.blue;
                goBtn.onclick = function() {
                    document.getElementById('game-over').classList.remove('visible');
                    // Restore button for future use
                    goBtn.textContent = 'New Game';
                    goBtn.onclick = function() { newGame(); };
                    MAX_RANGE = 4;
                    questMode = false;
                    document.getElementById('quest-indicator').style.display = 'none';
                    resetState();
                    genGrid();
                    renderHistory();
                    updateUI();
                    render();
                    document.getElementById('menu-screen').classList.remove('hidden');
                    showQuestScreen(playerWon);
                };

                updateCanvasGlow();
                overlay.classList.add('visible');
                return;
            }

            if (onlineMode) {
                const myColor = onlineRole === 'host' ? 'blue' : 'red';
                const myScore = myColor === 'blue' ? scores.blue : scores.red;
                const oppScore = myColor === 'blue' ? scores.red : scores.blue;

                scoresEl.innerHTML =
                    '<span style="color:#60a5fa">Blue: ' + formatScorePercent(scores.blue) + '</span>' +
                    '  \u2014  ' +
                    '<span style="color:#f87171">Red: ' + formatScorePercent(scores.red) + '</span>';

                if (myScore > oppScore) {
                    title.textContent = 'You Win!';
                    title.style.color = '#34d399';
                    subtitle.textContent = 'by ' + formatScorePercent(myScore - oppScore) + ' territory';
                } else if (oppScore > myScore) {
                    title.textContent = 'You Lose!';
                    title.style.color = '#f87171';
                    subtitle.textContent = 'by ' + formatScorePercent(oppScore - myScore) + ' territory';
                } else {
                    title.textContent = 'Draw!';
                    title.style.color = '#e2e8f0';
                    subtitle.textContent = 'A perfect tie!';
                }

                // Update Firebase status
                if (onlineGameRef) {
                    onlineGameRef.child('status').set('finished').catch(() => {});
                }
            } else if (gameMode === 'pvc') {
                scoresEl.innerHTML =
                    '<span style="color:#60a5fa">CPU: ' + formatScorePercent(scores.blue) + '</span>' +
                    '  \u2014  ' +
                    '<span style="color:#f87171">You: ' + formatScorePercent(scores.red) + '</span>';

                if (scores.red > scores.blue) {
                    title.textContent = 'You Win!';
                    title.style.color = '#34d399';
                    subtitle.textContent = 'by ' + formatScorePercent(scores.red - scores.blue) + ' territory';
                } else if (scores.blue > scores.red) {
                    title.textContent = 'Computer Wins!';
                    title.style.color = '#60a5fa';
                    subtitle.textContent = 'by ' + formatScorePercent(scores.blue - scores.red) + ' territory';
                } else {
                    title.textContent = 'Draw!';
                    title.style.color = '#e2e8f0';
                    subtitle.textContent = 'Both sides tied exactly';
                }
            } else {
                scoresEl.innerHTML =
                    '<span style="color:#60a5fa">Blue: ' + formatScorePercent(scores.blue) + '</span>' +
                    '  \u2014  ' +
                    '<span style="color:#f87171">Red: ' + formatScorePercent(scores.red) + '</span>';

                if (scores.blue > scores.red) {
                    title.textContent = 'Blue Wins!';
                    title.style.color = '#60a5fa';
                    subtitle.textContent = 'by ' + formatScorePercent(scores.blue - scores.red) + ' territory';
                } else if (scores.red > scores.blue) {
                    title.textContent = 'Red Wins!';
                    title.style.color = '#f87171';
                    subtitle.textContent = 'by ' + formatScorePercent(scores.red - scores.blue) + ' territory';
                } else {
                    title.textContent = 'Draw!';
                    title.style.color = '#e2e8f0';
                    subtitle.textContent = 'Both players tied exactly';
                }
            }

            updateCanvasGlow();
            overlay.classList.add('visible');
        }

        /* ===== Rendering ===== */
        function render() {
            // 1. Background
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(0, 0, CW, CH);

            // 2. Grid background
            ctx.fillStyle = '#f8f5ee';
            ctx.fillRect(PAD, PAD, GRID_PX, GRID_PX);

            // 3. Territory (hidden during Sneaky Snake stealth, unless revealing)
            const isSnakeStealth = questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'stealth' && !questSnakeRevealing && !gameOver;
            if (!isSnakeStealth) {
                ctx.drawImage(tCvs, PAD, PAD);
            }

            // 3a-split. Splitboard: gray out opponent's half
            if (questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'splitboard') {
                const halfCol = Math.floor(GRID / 2);
                if (player === 'red') {
                    // Gray out AI's half (right side) for the player
                    ctx.fillStyle = 'rgba(15,23,42,0.35)';
                    ctx.fillRect(PAD + halfCol * CELL, PAD, (GRID - halfCol) * CELL, GRID_PX);
                } else {
                    // Gray out player's half (left side) for the AI
                    ctx.fillStyle = 'rgba(15,23,42,0.35)';
                    ctx.fillRect(PAD, PAD, halfCol * CELL, GRID_PX);
                }
            }

            // 3b. Range gray-out
            if (sel.length > 0) {
                for (let r = 0; r < GRID; r++) {
                    for (let c = 0; c < GRID; c++) {
                        if (!inRange(r, c)) {
                            ctx.fillStyle = 'rgba(15,23,42,0.55)';
                            ctx.fillRect(PAD + c * CELL, PAD + r * CELL, CELL, CELL);
                        }
                    }
                }
            }

            // 3c. Frozen cell overlays (quest mode)
            if (questMode && questFrozenCells.length > 0) {
                const now = performance.now();
                const shimmer = 0.4 + 0.3 * Math.sin(now / 300);
                for (const fc of questFrozenCells) {
                    ctx.fillStyle = 'rgba(147,197,253,' + shimmer.toFixed(2) + ')';
                    ctx.fillRect(PAD + fc.c * CELL, PAD + fc.r * CELL, CELL, CELL);
                    // Ice crystal indicator
                    ctx.fillStyle = 'rgba(255,255,255,0.7)';
                    ctx.font = '16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('\u2744', PAD + fc.c * CELL + CELL/2, PAD + fc.r * CELL + CELL/2 - 12);
                }
            }

            // 3d. Tutorial highlights
            if (tutorialActive && tutorialStep < TUTORIAL_STEPS.length) {
                const step = TUTORIAL_STEPS[tutorialStep];
                const highlights = step.highlights || [];

                // Also highlight remaining targets
                let allHighlights = [...highlights];
                if (step.action === 'click') {
                    let targets = step.target ? [step.target] : (step.targets || []);
                    for (let i = tutorialTargetIndex; i < targets.length; i++) {
                        if (!allHighlights.some(h => h.r === targets[i].r && h.c === targets[i].c)) {
                            allHighlights.push(targets[i]);
                        }
                    }
                }

                for (const h of allHighlights) {
                    ctx.strokeStyle = '#34d399';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(PAD + h.c * CELL + 2, PAD + h.r * CELL + 2, CELL - 4, CELL - 4);
                    ctx.fillStyle = 'rgba(52, 211, 153, 0.12)';
                    ctx.fillRect(PAD + h.c * CELL + 1, PAD + h.r * CELL + 1, CELL - 2, CELL - 2);
                }
            }

            // 4. Grid lines
            ctx.strokeStyle = '#c8bea8';
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID; i++) {
                const x = PAD + i * CELL + 0.5;
                const y = PAD + i * CELL + 0.5;
                ctx.beginPath(); ctx.moveTo(x, PAD); ctx.lineTo(x, PAD + GRID_PX); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(PAD, y); ctx.lineTo(PAD + GRID_PX, y); ctx.stroke();
            }

            // 4a-split. Splitboard divider line
            if (questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'splitboard') {
                const halfCol = Math.floor(GRID / 2);
                const divX = PAD + halfCol * CELL;
                ctx.save();
                ctx.strokeStyle = '#f97316';
                ctx.lineWidth = 4;
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                ctx.moveTo(divX, PAD);
                ctx.lineTo(divX, PAD + GRID_PX);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.restore();
            }

            // 4b. Hover highlight
            if (hoverCell && !gameOver && !submitting && !aiThinking && !(onlineMode && !isMyTurn())) {
                const hs = sel.some(s => s.r === hoverCell.r && s.c === hoverCell.c);
                if (!hs && inRange(hoverCell.r, hoverCell.c)) {
                    ctx.fillStyle = player === 'blue'
                        ? 'rgba(59,130,246,0.12)' : 'rgba(239,68,68,0.12)';
                    ctx.fillRect(
                        PAD + hoverCell.c * CELL + 1,
                        PAD + hoverCell.r * CELL + 1,
                        CELL - 1, CELL - 1
                    );
                }
            }

            // 5. Selection highlights
            const hasSelection = sel.length > 0;
            if (hasSelection) {
                const hlFill = player === 'blue'
                    ? 'rgba(59,130,246,0.15)' : 'rgba(239,68,68,0.15)';
                const lineCol = player === 'blue'
                    ? 'rgba(59,130,246,0.8)' : 'rgba(239,68,68,0.8)';

                for (const s of sel) {
                    ctx.fillStyle = hlFill;
                    ctx.fillRect(PAD + s.c * CELL + 1, PAD + s.r * CELL + 1, CELL - 1, CELL - 1);
                }

                // Connecting lines (solid)
                if (sel.length >= 2) {
                    ctx.strokeStyle = lineCol;
                    ctx.lineWidth = 2.5;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    for (let i = 0; i < sel.length; i++) {
                        const p = cellCenter(sel[i].r, sel[i].c);
                        if (i === 0) ctx.moveTo(p.x, p.y);
                        else ctx.lineTo(p.x, p.y);
                    }
                    ctx.stroke();
                }

                // Polygon preview: dashed closing line (last -> first)
                if (sel.length >= 3) {
                    const first = cellCenter(sel[0].r, sel[0].c);
                    const last = cellCenter(sel[sel.length - 1].r, sel[sel.length - 1].c);
                    ctx.strokeStyle = lineCol;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 4]);
                    ctx.beginPath();
                    ctx.moveTo(last.x, last.y);
                    ctx.lineTo(first.x, first.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // 6. Letters
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            if (shakeupAnim) {
                // During shakeup animation: draw letters at interpolated positions
                const elapsed = performance.now() - shakeupAnim.startTime;
                const t = Math.min(elapsed / shakeupAnim.duration, 1);
                // Smooth ease-in-out
                const eased = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
                ctx.font = 'bold 22px "Courier New", monospace';
                ctx.fillStyle = '#334155';
                for (const m of shakeupAnim.moves) {
                    const x = m.fromX + (m.toX - m.fromX) * eased;
                    const y = m.fromY + (m.toY - m.fromY) * eased;
                    ctx.fillText(m.letter, x, y);
                }
            } else {
                for (let r = 0; r < GRID; r++) {
                    for (let c = 0; c < GRID; c++) {
                        if (grid[r][c] === '') continue;
                        const p = cellCenter(r, c);
                        const isSel = sel.some(s => s.r === r && s.c === c);
                        const oor = hasSelection && !isSel && !inRange(r, c);
                        ctx.font = isSel
                            ? 'bold 24px "Courier New", monospace'
                            : 'bold 22px "Courier New", monospace';
                        if (isSel) {
                            ctx.fillStyle = player === 'blue' ? '#1d4ed8' : '#b91c1c';
                        } else if (oor) {
                            ctx.fillStyle = '#64748b';
                        } else {
                            ctx.fillStyle = '#334155';
                        }
                        ctx.fillText(grid[r][c], p.x, p.y);
                    }
                }
            }

            // 7. Selection badges
            if (hasSelection) {
                const badgeCol = player === 'blue' ? '#2563eb' : '#dc2626';
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                for (let i = 0; i < sel.length; i++) {
                    const bx = PAD + sel[i].c * CELL + CELL - 10;
                    const by = PAD + sel[i].r * CELL + 10;
                    ctx.fillStyle = badgeCol;
                    ctx.beginPath();
                    ctx.arc(bx, by, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.fillText(i + 1, bx, by);
                }
            }
        }

        /* ===== UI updates ===== */
        function updateUI() {
            const ti = document.getElementById('turn-indicator');
            if (gameOver) {
                ti.textContent = 'Game Over';
                ti.style.color = '#94a3b8';
            } else if (onlineMode) {
                if (isMyTurn()) {
                    ti.textContent = "Your Turn";
                    ti.style.color = onlineRole === 'host' ? '#60a5fa' : '#f87171';
                } else {
                    ti.textContent = "Opponent's Turn";
                    ti.style.color = onlineRole === 'host' ? '#f87171' : '#60a5fa';
                }
            } else if (questMode) {
                const enemy = QUEST_ENEMIES[questEnemyIndex];
                if (player === 'blue') {
                    ti.textContent = enemy.name + "'s Turn";
                    ti.style.color = '#60a5fa';
                } else {
                    ti.textContent = "Your Turn";
                    ti.style.color = '#f87171';
                }
            } else if (gameMode === 'pvc') {
                if (player === 'blue') {
                    ti.textContent = aiThinking ? "Computer's Turn" : "Computer's Turn";
                    ti.style.color = '#60a5fa';
                } else {
                    ti.textContent = "Your Turn";
                    ti.style.color = '#f87171';
                }
            } else {
                ti.textContent = player === 'blue' ? "Blue's Turn" : "Red's Turn";
                ti.style.color = player === 'blue' ? '#60a5fa' : '#f87171';
            }

            const displayBlue = (questMode && QUEST_ENEMIES[questEnemyIndex]?.power === 'doubleturn')
                ? Math.ceil(turnsLeft.blue / 2) : turnsLeft.blue;
            document.getElementById('turns-left').innerHTML =
                '<span class="turns-blue">Blue: ' + displayBlue + '</span> | <span class="turns-red">Red: ' + turnsLeft.red + '</span>';

            // Animated score counters
            startScoreAnimation();

            const wd = document.getElementById('word-display');
            if (sel.length === 0) {
                wd.textContent = 'Select letters to form a word...';
                wd.style.color = '#94a3b8';
            } else {
                const letters = sel.map(s => grid[s.r][s.c]).join(' - ');
                const str = sel.length >= 3
                    ? '  (Strength ' + Math.min(sel.length - 2, 5) + ')'
                    : '';
                wd.textContent = letters + str;
                wd.style.color = player === 'blue' ? '#60a5fa' : '#f87171';
                wd.classList.remove('word-pop');
                void wd.offsetWidth;
                wd.classList.add('word-pop');
            }
        }

        function msg(text) {
            const el = document.getElementById('message');
            el.textContent = text;
            el.style.opacity = '1';
            if (msgTimer) clearTimeout(msgTimer);
            msgTimer = setTimeout(() => { el.style.opacity = '0'; }, 3000);
        }

        /* ===== Quest Mode Functions ===== */
        let questScrollAnimating = false;

        function showQuestScreen(animateFromDefeat) {
            const screen = document.getElementById('quest-screen');
            screen.classList.remove('hidden');
            renderQuestEnemies();

            if (animateFromDefeat) {
                // Wait for renderQuestEnemies' requestAnimationFrame to position chain first
                requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    const chain = document.getElementById('quest-chain');
                    const targetBottom = chain.style.bottom;
                    // Start one node lower (previous enemy was centered)
                    const nodeHeight = getQuestNodeHeight();
                    chain.style.transition = 'none';
                    chain.style.bottom = (parseInt(targetBottom) - nodeHeight) + 'px';
                    // Force reflow
                    void chain.offsetHeight;
                    // Flash effect
                    const flash = document.getElementById('quest-flash');
                    flash.classList.remove('flash-active');
                    void flash.offsetHeight;
                    flash.classList.add('flash-active');
                    // Spawn sparkles
                    spawnQuestSparkles();
                    // Animate to correct position
                    chain.style.transition = 'bottom 1.2s cubic-bezier(0.22, 1, 0.36, 1)';
                    requestAnimationFrame(() => {
                        chain.style.bottom = targetBottom;
                    });
                    setTimeout(() => flash.classList.remove('flash-active'), 1300);
                });
                });
            }
        }

        function hideQuestScreen() {
            document.getElementById('quest-screen').classList.add('hidden');
        }

        function getQuestNodeHeight() {
            // Approximate height of one card + connector
            const card = document.querySelector('.quest-enemy-card');
            if (card) {
                return card.offsetHeight + 80; // card height + connector
            }
            return 320; // fallback
        }

        function spawnQuestSparkles() {
            const screen = document.getElementById('quest-screen');
            const colors = ['#f97316', '#fbbf24', '#fb923c', '#facc15', '#34d399', '#a78bfa'];
            for (let i = 0; i < 30; i++) {
                const spark = document.createElement('div');
                spark.className = 'quest-sparkle';
                const size = 3 + Math.random() * 6;
                spark.style.width = size + 'px';
                spark.style.height = size + 'px';
                spark.style.left = (20 + Math.random() * 60) + '%';
                spark.style.top = (30 + Math.random() * 40) + '%';
                spark.style.background = colors[Math.floor(Math.random() * colors.length)];
                spark.style.animationDuration = (0.6 + Math.random() * 0.8) + 's';
                screen.appendChild(spark);
                setTimeout(() => spark.remove(), 1500);
            }
        }

        function renderQuestEnemies() {
            const chain = document.getElementById('quest-chain');

            // Determine the current enemy index (first non-defeated)
            let currentIdx = 0;
            for (let i = 0; i < QUEST_ENEMIES.length; i++) {
                if (!questProgress.includes(i)) { currentIdx = i; break; }
                if (i === QUEST_ENEMIES.length - 1) currentIdx = QUEST_ENEMIES.length; // all defeated
            }

            // Build chain HTML: enemies listed bottom-to-top (index 0 at bottom, 5 at top)
            // But in DOM order, top-to-bottom, so index 5 first
            let html = '';
            for (let i = QUEST_ENEMIES.length - 1; i >= 0; i--) {
                const enemy = QUEST_ENEMIES[i];
                const defeated = questProgress.includes(i);
                const available = !defeated && (i === 0 || questProgress.includes(i - 1));
                const locked = !defeated && !available;
                const statusClass = locked ? 'locked' : (defeated ? 'defeated' : 'available');

                // Connector line above (between this node and the one above it in DOM = next index)
                // No connector above the topmost node
                if (i < QUEST_ENEMIES.length - 1) {
                    const lineClass = defeated ? 'defeated-line' : '';
                    html += '<div class="quest-connector ' + lineClass + '"></div>';
                }

                html += '<div class="quest-node">';
                html += '<div class="quest-enemy-card ' + statusClass + '" data-enemy="' + enemy.id + '">';
                html += '<div class="qec-img-wrap"><img src="' + enemy.img + '" alt="' + enemy.name + '"></div>';
                html += '<div class="qec-info">';
                html += '<div class="qec-name">' + enemy.name + '</div>';
                html += '<div class="qec-diff ' + enemy.difficulty + '">' + enemy.difficulty + '</div>';
                html += '<div class="qec-power">' + enemy.desc + '</div>';

                if (defeated) {
                    html += '<span class="quest-status-badge defeated-badge">\u2714 Defeated</span>';
                } else if (available) {
                    html += '<button class="quest-battle-btn" onclick="startQuestBattle(' + i + ')">Battle!</button>';
                } else {
                    html += '<span class="quest-status-badge locked-badge">\uD83D\uDD12 Locked</span>';
                }

                html += '</div></div></div>';
            }

            chain.innerHTML = html;

            // Position chain so the current enemy card is centered vertically on screen.
            // Chain is laid out top-to-bottom: [enemy5, conn, enemy4, conn, ..., enemy0]
            // We need to find the offset of the current enemy's card within the chain
            // and set `bottom` so that card is centered.
            requestAnimationFrame(() => {
                positionQuestChain(currentIdx);
            });
        }

        function positionQuestChain(currentIdx) {
            const chain = document.getElementById('quest-chain');
            const screen = document.getElementById('quest-screen');
            const screenH = screen.offsetHeight;
            const chainH = chain.offsetHeight;

            // The current enemy in DOM is at reverse index: QUEST_ENEMIES.length - 1 - currentIdx
            // Find the actual card element
            const cards = chain.querySelectorAll('.quest-enemy-card');
            // Cards are in DOM order: index 5, 4, 3, 2, 1, 0
            // So currentIdx maps to cards[QUEST_ENEMIES.length - 1 - currentIdx]
            const domIdx = QUEST_ENEMIES.length - 1 - Math.min(currentIdx, QUEST_ENEMIES.length - 1);
            const card = cards[domIdx];

            if (!card) {
                chain.style.bottom = '80px';
                return;
            }

            // card's offset from top of chain
            const cardTop = card.offsetTop;
            const cardH = card.offsetHeight;
            const cardCenter = cardTop + cardH / 2;

            // We want cardCenter to be at screenH / 2
            // chain is positioned with `bottom`, so:
            // bottom of chain = screenH - (chain.offsetTop + chainH)
            // We want: chain top + cardCenter = screenH/2
            // chain top = screenH/2 - cardCenter
            // bottom = screenH - (chain top + chainH) = screenH - (screenH/2 - cardCenter + chainH)
            // bottom = screenH/2 + cardCenter - chainH
            const bottomVal = (screenH / 2) + cardCenter - chainH;

            chain.style.bottom = bottomVal + 'px';
        }

        function resetQuestProgress() {
            if (!confirm('Reset all campaign progress? This cannot be undone.')) return;
            questProgress = [];
            localStorage.setItem('questProgress', '[]');
            renderQuestEnemies();
        }

        function startQuestBattle(enemyIndex) {
            questMode = true;
            questEnemyIndex = enemyIndex;
            questTurnCount = 0;
            questFrozenCells = [];
            questWalrusSpellsUsed = 0;
            questWalrusSpellOrder = [];
            questWalrusDoubleNext = false;
            questSnakeMoves = [];
            questSnakeRevealing = false;

            const enemy = QUEST_ENEMIES[enemyIndex];
            gameMode = 'pvc';
            aiDifficulty = enemy.difficulty;

            // Per-enemy board size and turns, defaulting to 11x11 / 8 turns
            recalculateGridSize(enemy.boardSize || 11);
            resizeCanvases();
            TURNS_EACH = enemy.turns || 8;
            timerEnabled = false;
            timerDuration = 0;

            // Squirrel: extended range for AI (handled in aiFindWords)
            MAX_RANGE = 4;

            resetState();

            // Hippo: give AI double turns so it doesn't run out early
            if (enemy.aiTurns) {
                turnsLeft.blue = enemy.aiTurns;
            }

            genGrid();
            buildValidWordSet();
            buildAIWordSets();

            // Hide screens, show game
            document.getElementById('quest-screen').classList.add('hidden');
            document.getElementById('menu-screen').classList.add('hidden');

            // Show quest indicator
            const qi = document.getElementById('quest-indicator');
            document.getElementById('qi-img').src = enemy.img;
            document.getElementById('qi-name').textContent = enemy.name;
            document.getElementById('qi-power').textContent = enemy.desc;
            qi.style.display = 'block';

            renderHistory();
            updateUI();
            render();
            updateCanvasGlow();

            // Pre-battle taunts and powers
            if (enemy.power === 'headstart') {
                applyDuckHeadstart();
                rebuildTerritoryVisual();
                render();
                document.getElementById('duck-taunt').classList.add('visible');
                // AI turn starts after player dismisses the taunt
            } else if (enemy.power === 'doubleturn') {
                document.getElementById('hippo-taunt').classList.add('visible');
            } else if (enemy.power === 'shortwords') {
                document.getElementById('flamingo-taunt').classList.add('visible');
            } else if (enemy.power === 'stealth') {
                document.getElementById('snake-taunt').classList.add('visible');
            } else if (enemy.power === 'superstrength') {
                document.getElementById('turtle-taunt').classList.add('visible');
            } else if (enemy.power === 'splitboard') {
                document.getElementById('panda-taunt').classList.add('visible');
            } else if (enemy.power === 'spells') {
                // Randomize spell order for turns 3, 5, 7
                const spellIds = WALRUS_SPELLS.map(s => s.id);
                for (let i = spellIds.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [spellIds[i], spellIds[j]] = [spellIds[j], spellIds[i]];
                }
                questWalrusSpellOrder = spellIds;
                document.getElementById('walrus-taunt').classList.add('visible');
            } else if (enemy.power === 'science') {
                document.getElementById('penguin-taunt').classList.add('visible');
            } else if (enemy.power === 'range') {
                document.getElementById('squirrel-taunt').classList.add('visible');
            } else if (enemy.power === 'shakeup') {
                document.getElementById('raccoon-taunt').classList.add('visible');
            } else if (enemy.power === 'none') {
                document.getElementById('goat-taunt').classList.add('visible');
            } else {
                // AI goes first
                setTimeout(() => aiTakeTurn(), 600);
            }
        }

        function applyDuckHeadstart() {
            // Fill 20% of the board with a contiguous blob of Blue territory
            const totalPixels = GRID_PX * GRID_PX;
            const targetCount = Math.floor(totalPixels * 0.20);

            // Pick a random seed point (away from edges for a nice blob)
            const margin = Math.floor(GRID_PX * 0.2);
            let seedX = margin + Math.floor(Math.random() * (GRID_PX - margin * 2));
            let seedY = margin + Math.floor(Math.random() * (GRID_PX - margin * 2));
            const seedIdx = seedY * GRID_PX + seedX;

            // BFS flood fill from the seed to create a contiguous mass
            const filled = new Uint8Array(totalPixels);
            const queue = [seedIdx];
            filled[seedIdx] = 1;
            let filledCount = 0;

            while (queue.length > 0 && filledCount < targetCount) {
                // Pick a random element from the queue for organic shape
                const qIdx = Math.floor(Math.random() * queue.length);
                const pxIdx = queue[qIdx];
                queue[qIdx] = queue[queue.length - 1];
                queue.pop();

                tOwner[pxIdx] = TEAM.BLUE;
                tStrength[pxIdx] = 2;
                filledCount++;

                // Add neighbors (4-directional)
                const x = pxIdx % GRID_PX;
                const y = Math.floor(pxIdx / GRID_PX);
                const neighbors = [
                    y > 0 ? pxIdx - GRID_PX : -1,
                    y < GRID_PX - 1 ? pxIdx + GRID_PX : -1,
                    x > 0 ? pxIdx - 1 : -1,
                    x < GRID_PX - 1 ? pxIdx + 1 : -1
                ];
                for (const n of neighbors) {
                    if (n >= 0 && n < totalPixels && !filled[n]) {
                        filled[n] = 1;
                        queue.push(n);
                    }
                }
            }
        }

        function dismissDuckTaunt() {
            document.getElementById('duck-taunt').classList.remove('visible');
            // Now start the AI's first turn
            setTimeout(() => aiTakeTurn(), 600);
        }

        function dismissGoatTaunt() {
            document.getElementById('goat-taunt').classList.remove('visible');
            setTimeout(() => aiTakeTurn(), 600);
        }

        function dismissSnakeTaunt() {
            document.getElementById('snake-taunt').classList.remove('visible');
            setTimeout(() => aiTakeTurn(), 600);
        }

        function dismissHippoTaunt() {
            document.getElementById('hippo-taunt').classList.remove('visible');
            setTimeout(() => aiTakeTurn(), 600);
        }

        function dismissRaccoonTaunt() {
            document.getElementById('raccoon-taunt').classList.remove('visible');
            setTimeout(() => aiTakeTurn(), 600);
        }

        function dismissFlamingoTaunt() {
            document.getElementById('flamingo-taunt').classList.remove('visible');
            setTimeout(() => aiTakeTurn(), 600);
        }

        function dismissTurtleTaunt() {
            document.getElementById('turtle-taunt').classList.remove('visible');
            setTimeout(() => aiTakeTurn(), 600);
        }

        function dismissSquirrelTaunt() {
            document.getElementById('squirrel-taunt').classList.remove('visible');
            setTimeout(() => aiTakeTurn(), 600);
        }

        function dismissPandaTaunt() {
            document.getElementById('panda-taunt').classList.remove('visible');
            setTimeout(() => aiTakeTurn(), 600);
        }

        function dismissPenguinTaunt() {
            document.getElementById('penguin-taunt').classList.remove('visible');
            setTimeout(() => aiTakeTurn(), 600);
        }

        function dismissWalrusTaunt() {
            document.getElementById('walrus-taunt').classList.remove('visible');
            setTimeout(() => aiTakeTurn(), 600);
        }

        function resetQuestProgress() {
            if (!confirm('Reset all campaign progress? This cannot be undone.')) return;
            questProgress = [];
            localStorage.setItem('questProgress', '[]');
            renderQuestEnemies();
        }

        /* Quest power application */
        async function applyQuestPower(timing) {
            if (!questMode) return;
            const enemy = QUEST_ENEMIES[questEnemyIndex];

            // Hip Hop Hippo: double turn (handled in aiTakeTurn)

            // Duck's power ('headstart') is applied before the game starts, not per-turn

            if (enemy.power === 'shakeup' && timing === 'beforeAI') {
                // Rowdy Raccoon: scramble every 3 turns with animated letter movement
                if (questTurnCount > 0 && questTurnCount % 2 === 0) {
                    // Show overlay briefly
                    document.getElementById('shakeup-img').src = enemy.img;
                    document.getElementById('shakeup-overlay').classList.add('visible');
                    await new Promise(r => setTimeout(r, 1200));
                    document.getElementById('shakeup-overlay').classList.remove('visible');

                    // Collect existing letters with their source positions
                    const letters = [];
                    const sourcePositions = [];
                    const allPositions = [];
                    for (let r = 0; r < GRID; r++) {
                        for (let c = 0; c < GRID; c++) {
                            allPositions.push({r, c});
                            if (grid[r][c] !== '') {
                                letters.push(grid[r][c]);
                                sourcePositions.push({r, c});
                            }
                        }
                    }

                    // Shuffle all positions, take the first letters.length as destinations
                    // Remaining positions stay blank (preserving the same blank count)
                    const shuffledPositions = allPositions.map(p => ({...p}));
                    for (let i = shuffledPositions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [shuffledPositions[i], shuffledPositions[j]] = [shuffledPositions[j], shuffledPositions[i]];
                    }
                    const destPositions = shuffledPositions.slice(0, letters.length);

                    // Build animation move list
                    const moves = [];
                    for (let i = 0; i < letters.length; i++) {
                        const from = cellCenter(sourcePositions[i].r, sourcePositions[i].c);
                        const to = cellCenter(destPositions[i].r, destPositions[i].c);
                        moves.push({
                            letter: letters[i],
                            fromX: from.x, fromY: from.y,
                            toX: to.x, toY: to.y
                        });
                    }

                    // Clear grid before animation (letters rendered by animation system)
                    for (let r = 0; r < GRID; r++) {
                        for (let c = 0; c < GRID; c++) {
                            grid[r][c] = '';
                        }
                    }

                    // Start animation
                    const duration = 2500;
                    shakeupAnim = { moves, startTime: performance.now(), duration };

                    function animateShakeup() {
                        render();
                        const elapsed = performance.now() - shakeupAnim.startTime;
                        if (elapsed < duration) {
                            requestAnimationFrame(animateShakeup);
                        } else {
                            // Animation done — place letters in their final positions
                            shakeupAnim = null;
                            for (let i = 0; i < letters.length; i++) {
                                grid[destPositions[i].r][destPositions[i].c] = letters[i];
                            }
                            render();
                        }
                    }
                    requestAnimationFrame(animateShakeup);

                    // Wait for animation to complete
                    await new Promise(r => setTimeout(r, duration + 100));
                    msg('Raccoon scrambled the board!');
                    await new Promise(r => setTimeout(r, 300));
                }
            }

            if (enemy.power === 'spells' && timing === 'afterAI') {
                // Wizardly Walrus: cast spells based on player's remaining turns
                // Spells trigger when player has 6, 4, and 2 turns remaining
                const totalPlayerTurns = (enemy.turns || TURNS_EACH);
                const t1 = totalPlayerTurns - Math.floor(totalPlayerTurns / 4);       // ~75% remaining
                const t2 = Math.ceil(totalPlayerTurns / 2);                           // ~50% remaining
                const t3 = Math.floor(totalPlayerTurns / 4);                          // ~25% remaining
                const spellThresholds = [t1, t2, t3];
                const spellIdx = spellThresholds.indexOf(turnsLeft.red);
                if (spellIdx !== -1 && questWalrusSpellsUsed <= spellIdx) {
                    const spellId = questWalrusSpellOrder[spellIdx];
                    const spell = WALRUS_SPELLS.find(s => s.id === spellId);
                    if (spell) {
                        questWalrusSpellsUsed = spellIdx + 1;

                        // Show spell overlay
                        document.getElementById('spell-img').src = enemy.img;
                        document.getElementById('spell-name').textContent = spell.name;
                        document.getElementById('spell-desc').textContent = spell.desc;
                        document.getElementById('spell-effect').textContent = 'Walrus casts ' + spell.name + '!';
                        document.getElementById('spell-overlay').classList.add('visible');

                        await new Promise(r => setTimeout(r, 2000));
                        document.getElementById('spell-overlay').classList.remove('visible');

                        if (spell.id === 'steal') {
                            // Steal a contiguous chunk (5-8%) of red territory via BFS
                            const totalPixels = GRID_PX * GRID_PX;
                            const redPixels = [];
                            for (let i = 0; i < totalPixels; i++) {
                                if (tOwner[i] === TEAM.RED) redPixels.push(i);
                            }
                            if (redPixels.length > 0) {
                                const stealPct = 0.05 + Math.random() * 0.03; // 5-8%
                                const stealCount = Math.floor(totalPixels * stealPct);
                                // BFS from a random red pixel to steal a contiguous chunk
                                const seed = redPixels[Math.floor(Math.random() * redPixels.length)];
                                const stolen = new Set();
                                const queue = [seed];
                                stolen.add(seed);
                                while (queue.length > 0 && stolen.size < stealCount) {
                                    const px = queue.shift();
                                    const x = px % GRID_PX;
                                    const y = Math.floor(px / GRID_PX);
                                    const neighbors = [
                                        y > 0 ? (y - 1) * GRID_PX + x : -1,
                                        y < GRID_PX - 1 ? (y + 1) * GRID_PX + x : -1,
                                        x > 0 ? y * GRID_PX + (x - 1) : -1,
                                        x < GRID_PX - 1 ? y * GRID_PX + (x + 1) : -1
                                    ];
                                    for (const n of neighbors) {
                                        if (n >= 0 && !stolen.has(n) && tOwner[n] === TEAM.RED) {
                                            stolen.add(n);
                                            queue.push(n);
                                            if (stolen.size >= stealCount) break;
                                        }
                                    }
                                }
                                for (const px of stolen) {
                                    tOwner[px] = TEAM.BLUE;
                                    tStrength[px] = 2;
                                }
                                rebuildTerritoryVisual();
                                render();
                            }
                            msg('Walrus stole your territory!');
                        }

                        if (spell.id === 'freeze') {
                            // Freeze 5 random cells for 2 turns
                            const available = [];
                            for (let r = 0; r < GRID; r++) {
                                for (let c = 0; c < GRID; c++) {
                                    if (grid[r][c] !== '' && !questFrozenCells.some(f => f.r === r && f.c === c)) {
                                        available.push({r, c});
                                    }
                                }
                            }
                            for (let i = 0; i < 5 && available.length > 0; i++) {
                                const idx = Math.floor(Math.random() * available.length);
                                questFrozenCells.push({r: available[idx].r, c: available[idx].c, turnsLeft: 2});
                                available.splice(idx, 1);
                            }
                            render();
                            msg('Walrus froze some cells!');
                        }

                        if (spell.id === 'short') {
                            questPlayerShortRange = true;
                            msg('Your letter range is limited to 2 tiles next turn!');
                        }

                        await new Promise(r => setTimeout(r, 400));
                    }
                }
            }
        }

        /* Victory screen */
        function showVictoryScreen() {
            const vs = document.getElementById('victory-screen');
            document.getElementById('victory-subtitle').textContent = 'You defeated all ' + QUEST_ENEMIES.length + ' enemies!';
            const portraits = document.getElementById('victory-portraits');
            let html = '';
            for (const enemy of QUEST_ENEMIES) {
                html += '<img class="victory-portrait" src="' + enemy.img + '" alt="' + enemy.name + '">';
            }
            portraits.innerHTML = html;
            vs.classList.add('visible');
            startConfetti();
        }

        function hideVictoryScreen() {
            document.getElementById('victory-screen').classList.remove('visible');
            stopConfetti();
            newGame();
        }

        /* Confetti animation */
        let confettiAnimId = null;
        let confettiParticles = [];

        function startConfetti() {
            const canvas = document.getElementById('confetti-canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const ctx2 = canvas.getContext('2d');

            confettiParticles = [];
            const colors = ['#f97316','#fbbf24','#34d399','#60a5fa','#a78bfa','#f87171','#e879f9'];
            for (let i = 0; i < 150; i++) {
                confettiParticles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height - canvas.height,
                    w: 6 + Math.random() * 6,
                    h: 4 + Math.random() * 4,
                    vx: (Math.random() - 0.5) * 3,
                    vy: 1.5 + Math.random() * 3,
                    rot: Math.random() * 360,
                    rotSpeed: (Math.random() - 0.5) * 10,
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
            }

            function animateConfetti() {
                ctx2.clearRect(0, 0, canvas.width, canvas.height);
                for (const p of confettiParticles) {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.rot += p.rotSpeed;
                    if (p.y > canvas.height + 20) {
                        p.y = -10;
                        p.x = Math.random() * canvas.width;
                    }
                    ctx2.save();
                    ctx2.translate(p.x, p.y);
                    ctx2.rotate(p.rot * Math.PI / 180);
                    ctx2.fillStyle = p.color;
                    ctx2.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
                    ctx2.restore();
                }
                confettiAnimId = requestAnimationFrame(animateConfetti);
            }
            confettiAnimId = requestAnimationFrame(animateConfetti);
        }

        function stopConfetti() {
            if (confettiAnimId) {
                cancelAnimationFrame(confettiAnimId);
                confettiAnimId = null;
            }
            const canvas = document.getElementById('confetti-canvas');
            const ctx2 = canvas.getContext('2d');
            ctx2.clearRect(0, 0, canvas.width, canvas.height);
        }

        /* ===== Start ===== */
        window.addEventListener('DOMContentLoaded', () => {
            initCanvas();
            genGrid();
            updateUI();
            render();

            document.getElementById('quest-card-desc').textContent = 'Battle ' + QUEST_ENEMIES.length + ' unique enemies in a campaign';

            // Temp: populate quest test dropdown
            const sel = document.getElementById('quest-test-select');
            QUEST_ENEMIES.forEach((e, i) => {
                const opt = document.createElement('option');
                opt.value = i;
                opt.textContent = e.name;
                sel.appendChild(opt);
            });
            sel.addEventListener('change', () => {
                const idx = parseInt(sel.value);
                sel.selectedIndex = 0;
                startQuestBattle(idx);
            });

            // Load menu pixel art decorations
            const decoMap = {
                'deco-palm-left': MENU_ASSETS.palmTall,
                'deco-palm-right': MENU_ASSETS.palmBend,
                'deco-palm-bg': MENU_ASSETS.palmSmall,
                'deco-bush-left': MENU_ASSETS.bushLarge,
                'deco-bush-right': MENU_ASSETS.bushSmall,
                'deco-grass-1': MENU_ASSETS.grassLarge,
                'deco-grass-2': MENU_ASSETS.grassSmall,
                'deco-grass-3': MENU_ASSETS.grassLarge,
                'deco-flower-red': MENU_ASSETS.flowerRed,
                'deco-flower-purple': MENU_ASSETS.flowerPurple,
                'deco-flower-yellow': MENU_ASSETS.flowerYellow
            };
            for (const [cls, src] of Object.entries(decoMap)) {
                const el = document.querySelector('.' + cls);
                if (el) el.src = src;
            }
        });
    </script>
</body>
</html>
